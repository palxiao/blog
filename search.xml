<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>浅谈vue2的12种组件通信方式及理解</title>
      <link href="/2021/04/13/2021/vue2%E9%80%9A%E4%BF%A1/"/>
      <url>/2021/04/13/2021/vue2%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<p><em>重新梳理了一下，个人认为Vue中组件通信思想与React一致，都是单向数据流，高阶流向低阶(父传子)，子组件只可通知父组件，此时数据还是在父级变更而不是发生流动。</em></p><h2 id="1-props"><a href="#1-props" class="headerlink" title="1. props"></a>1. props</h2><blockquote><p>高频使用</p></blockquote><p>父组件向子组件传递参数。 <a href="https://cn.vuejs.org/v2/guide/components-props.html#ad">Vue文档: props</a></p><h2 id="2-emit"><a href="#2-emit" class="headerlink" title="2. $emit"></a>2. <code>$emit</code></h2><blockquote><p>高频使用</p></blockquote><p>子组件通知父组件执行对应函数，可携带参数。 <a href="https://cn.vuejs.org/v2/api/#vm-emit">Vue文档: $emit</a></p><h2 id="3-refs"><a href="#3-refs" class="headerlink" title="3. $refs"></a>3. <code>$refs</code></h2><blockquote><p>高频使用，也可用在DOM元素操作</p></blockquote><p>通信上属于父组件向子组件传递。通过给子组件设置ref属性，使用 <code>this.$refs</code> 对象来获取实例，即可直接访问及调用子组件上的属性和方法。 <a href="https://cn.vuejs.org/v2/api/#vm-refs">Vue文档: refs</a></p><h2 id="4-Vuex-状态管理器"><a href="#4-Vuex-状态管理器" class="headerlink" title="4. Vuex 状态管理器"></a>4. Vuex 状态管理器</h2><blockquote><p>需注意场景使用，可以很好地满足复杂数据交互，在SPA应用中无障碍通信，但频繁使用会增加代码耦合度。</p></blockquote><p>主要以<code>State</code>、<code>Getters</code>、<code>Mutations</code>、<code>Actions</code>四个核心组成，约定了对数据的变更只在 <code>Mutations</code> 中，以 <code>store.commit</code>触发，异步操作则放在 <code>Actions</code> 中，以 <code>store.dispatch</code> 触发。 <a href="https://vuex.vuejs.org/zh/">Vuex官网文档</a></p><h2 id="5-root、-parent、-children"><a href="#5-root、-parent、-children" class="headerlink" title="5. $root、$parent、$children"></a>5. <code>$root</code>、<code>$parent</code>、<code>$children</code></h2><blockquote><p>不常使用</p></blockquote><p>这三个的作用都直接地体现在字面上。从组件通信层面上讲，用<code>$root</code>的场景不如使用Vuex，<code>$parent</code> 用 <code>$emit</code> 更好，而 <code>$children</code> 的使用场景几乎没有，毕竟 <code>$refs</code> 就够用了。 <a href="https://cn.vuejs.org/v2/guide/components-edge-cases.html">Vue文档: 处理边界情况</a></p><h2 id="6-sync修饰符"><a href="#6-sync修饰符" class="headerlink" title="6. .sync修饰符"></a>6. <code>.sync</code>修饰符</h2><blockquote><p>不推荐使用</p></blockquote><p>在通信方式中的经历最为曲折，曾被无情删除后来又重新添加，实现的是数据在通信中的“双向绑定”，其理念有违组件通信的原则所以不是很推荐使用，原理其实是对<code>$emit</code>进行了一层包装，让代码写的更少了而已。 <a href="https://cn.vuejs.org/v2/guide/components-custom-events.html#sync-%E4%BF%AE%E9%A5%B0%E7%AC%A6">Vue文档: sync-修饰符</a></p><h2 id="7-attrs"><a href="#7-attrs" class="headerlink" title="7. $attrs"></a>7. <code>$attrs</code></h2><blockquote><p>高阶组件中常用</p></blockquote><p>平时基本不会用到，但在组件颗粒度较细的场景中，以上提到的方式都不能优雅地解决诸如：A组件嵌套了B组件又嵌套了C组件，此时C要与A通信的情形，Vuex会增加代码耦合度得不偿失，<code>$root</code>又局限于A组件必须是为根组件，难道只能从A传到B再从B传到C吗？是的，但<code>$attrs</code>提供了一种传递“剩余参数”的作用，使操作更简便，用一个例子来了解更直观：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 A.vue 中 ：</span></span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;B name=<span class="string">&quot;shawn&quot;</span> id=<span class="string">&quot;1&quot;</span> /&gt; &lt;!-- 向B传递了参数name和id --&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> B <span class="keyword">from</span> <span class="string">&#x27;./B.vue&#x27;</span></span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 B.vue 中 ：</span></span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &#123;&#123; $attrs &#125;&#125; &lt;!-- 显示： &#123; <span class="attr">name</span>: <span class="string">&#x27;shawn&#x27;</span>, <span class="attr">id</span>: <span class="string">&#x27;1&#x27;</span> &#125; --&gt;</span><br><span class="line">    &lt;C v-bind=<span class="string">&quot;$attrs&quot;</span> /&gt; &lt;!-- 并未定义具体传哪些参数 --&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> C <span class="keyword">from</span> <span class="string">&#x27;./C.vue&#x27;</span></span><br><span class="line">......</span><br><span class="line">    props: &#123; id &#125; <span class="comment">// B中定义了对id的接收，那么就会被$attrs忽略，如果这里没有定义props，那么A传给B的数据会如数传到C那边</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 C.vue 中 ：</span></span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &#123;&#123; $attrs &#125;&#125; &lt;!-- 显示： &#123; <span class="attr">name</span>: <span class="string">&#x27;shawn&#x27;</span> &#125; --&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p><a href="https://cn.vuejs.org/v2/api/#vm-attrs">Vue文档: attrs</a></p><h2 id="8-listeners"><a href="#8-listeners" class="headerlink" title="8. $listeners"></a>8. <code>$listeners</code></h2><blockquote><p>高阶组件中常用</p></blockquote><p>和<code>$attrs</code>差不多，在上面的例子中往C组件添加属性 <code>v-on=&quot;$listeners&quot;</code> 即可，此时C组件能使用<code>$emit</code>调用A组件挂载的对应函数。 <a href="https://cn.vuejs.org/v2/api/#vm-listeners">Vue文档: listeners</a></p><h2 id="9-v-slot插槽"><a href="#9-v-slot插槽" class="headerlink" title="9. v-slot插槽"></a>9. v-slot插槽</h2><blockquote><p>组件化开发中较常用，此时组件中的通信可视为传递了模板代码</p></blockquote><p>注意<code>slot</code>和<code>slot-scope</code>是Vue早已废除的attribute，与v-slot并不相等。 <a href="https://cn.vuejs.org/v2/api/#v-slot">Vue文档: v-slot</a></p><h2 id="10-Event-Bus"><a href="#10-Event-Bus" class="headerlink" title="10. Event Bus"></a>10. Event Bus</h2><blockquote><p>较少使用</p></blockquote><p>典型的发布订阅模式，我比较喜欢叫它事件广播，用法简单，强在解耦能力。</p><h2 id="11-路由传参"><a href="#11-路由传参" class="headerlink" title="11. 路由传参"></a>11. 路由传参</h2><p>SPA应用中页面跳转可以视为组件变更，所以页面之间的通信也算组件通信了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$router.push(&#123;</span><br><span class="line">    name: <span class="string">&#x27;xxx&#x27;</span>, <span class="comment">// params传参一定要写name，只写path传参会失败</span></span><br><span class="line">    params: &#123; <span class="comment">/* 目标页面中this.$route.params...来获取 **/</span> &#125;,</span><br><span class="line">    query: &#123; <span class="comment">/* 参数写进url中传递，意味着刷新不会丢失 **/</span> &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="12-provide-inject"><a href="#12-provide-inject" class="headerlink" title="12. provide inject"></a>12. provide inject</h2><blockquote><p>开发组件库时使用</p></blockquote><p>允许一个祖先组件向其所有子孙后代注入一个依赖，provide向下派发inject用来接收。业务开发中无使用场景。 <a href="https://cn.vuejs.org/v2/api/#provide-inject">Vue文档: provide-inject</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>探索响应式数据原理，Proxy与reflect</title>
      <link href="/2021/04/12/2021/%E6%8E%A2%E7%B4%A2%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%E4%B9%8BProxy%E4%BB%A3%E7%90%86%E4%B8%8Ereflect%E5%8F%8D%E5%B0%84%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2021/04/12/2021/%E6%8E%A2%E7%B4%A2%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%E4%B9%8BProxy%E4%BB%A3%E7%90%86%E4%B8%8Ereflect%E5%8F%8D%E5%B0%84%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>首先上一段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">age</span>: <span class="number">1</span> &#125; <span class="comment">// 定义一个对象</span></span><br><span class="line"><span class="keyword">let</span> age = obj.age <span class="comment">// 将对象的age属性赋值给一个变量</span></span><br><span class="line">obj.age++ <span class="comment">// 对象的age属性发生了变化</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`age=<span class="subst">$&#123;age&#125;</span>`</span>, obj); <span class="comment">// 输出结果： age = 1  &#123;age: 2&#125;</span></span><br></pre></td></tr></table></figure><p>在obj的age属性变化时，变量age如果也随之变化，通常就需要定义一个函数赋予改变逻辑，在每次变化时手动执行一下函数。下面将以vue3中的响应式设计作为参考，来实现一个能自动响应方法。</p><h2 id="创建Demo"><a href="#创建Demo" class="headerlink" title="创建Demo"></a>创建Demo</h2><p>在Vue3中，数据响应模块被独立拆分了出来，现在我们可以随意创建一个node项目，然后npm或yarn安装包<code>@vue/reactivity</code>，这个包中有两个关键函数，<code>reactive</code> 和 <code>effect</code>，分别是创建一个响应式的对象和数据发生改变时的监听方法：</p><p><img src= "/img/loading__.gif" data-lazy-src="http://img.palxp.com/2021/04/1617552639769.png" alt="image.png"></p><p>使用包引入的函数，修改了上面的例子，满足了响应式需求，外部定义的变量跟随对象一起改变，打印出两个数值一致：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; reactive, effect &#125; = <span class="built_in">require</span>(<span class="string">&#x27;@vue/reactivity&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = reactive(&#123; <span class="attr">age</span>: <span class="number">1</span> &#125;) <span class="comment">// 这样就创建了一个响应式的对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> _age</span><br><span class="line"></span><br><span class="line">effect(<span class="function">() =&gt;</span> &#123; <span class="comment">// 对象变化时的监听响应操作，这里执行了两次</span></span><br><span class="line">    _age = obj.age</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`I&#x27;m <span class="subst">$&#123;_age&#125;</span> years old`</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">obj.age++ <span class="comment">// 操作对象，数据随之响应</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(_age, obj); <span class="comment">// 结果： 2 &#123; age: 2 &#125;</span></span><br></pre></td></tr></table></figure><h2 id="模拟实现基本数据类型Reacticity"><a href="#模拟实现基本数据类型Reacticity" class="headerlink" title="模拟实现基本数据类型Reacticity"></a>模拟实现基本数据类型Reacticity</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 收集依赖   2. 触发通知</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(val) &#123;</span><br><span class="line">        <span class="built_in">this</span>.effects = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">        <span class="built_in">this</span>._val = val</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title">value</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._val</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> <span class="title">value</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>._val = newVal</span><br><span class="line">    &#125;</span><br><span class="line">    depend() &#123;</span><br><span class="line">        <span class="comment">// 依赖收集...</span></span><br><span class="line">    &#125;</span><br><span class="line">    notify() &#123;</span><br><span class="line">        <span class="comment">// 触发通知...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">effectWatch</span>(<span class="params">effect</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>代码结构已有，先从结果出发，来看一个测试用例，假设从基本数据类型开始：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Test</span></span><br><span class="line"><span class="keyword">const</span> hero = <span class="keyword">new</span> Dep(<span class="number">1</span>) <span class="comment">// 传入一个数值</span></span><br><span class="line"><span class="keyword">let</span> lv</span><br><span class="line">effectWatch(<span class="function">() =&gt;</span> &#123; <span class="comment">// 响应对象的变动执行函数</span></span><br><span class="line">    lv = hero.value</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`等级提升： <span class="subst">$&#123;lv&#125;</span>`</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    hero.value++</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>照着上面的例子创建了这样一个英雄升级的例子，这里期望的运行结果应该是打印出 等级提升:2 这样的结果，开始完善函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">    effects: any</span><br><span class="line">    val: any</span><br><span class="line">    <span class="keyword">constructor</span>(val: any) &#123;</span><br><span class="line">        <span class="built_in">this</span>.effects = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">        <span class="built_in">this</span>.val = val</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title">value</span>() &#123;</span><br><span class="line">        <span class="built_in">this</span>.depend() <span class="comment">// get中开始收集依赖</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.val</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> <span class="title">value</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (newVal !== <span class="built_in">this</span>.val) &#123;</span><br><span class="line">            <span class="built_in">this</span>.val = newVal</span><br><span class="line">            <span class="built_in">this</span>.notify() <span class="comment">// 在set中触发通知</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    depend() &#123; <span class="comment">// 收集依赖</span></span><br><span class="line">        <span class="keyword">if</span> (Dep.currentEffect) &#123;</span><br><span class="line">            <span class="built_in">this</span>.effects.add(Dep.currentEffect)</span><br><span class="line">            Dep.currentEffect = <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    notify() &#123; <span class="comment">// 执行依赖</span></span><br><span class="line">        <span class="built_in">this</span>.effects.forEach(<span class="function">(<span class="params">effect: <span class="built_in">Function</span></span>) =&gt;</span> effect())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> currentEffect: any</span><br><span class="line">    <span class="keyword">static</span> trigger(e: <span class="built_in">Function</span>) &#123;</span><br><span class="line">        Dep.currentEffect = e</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">effectWatch</span>(<span class="params">effect: Function</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    effect() <span class="comment">// 模仿了vue3的effect函数，会先执行一次</span></span><br><span class="line">    Dep.trigger(effect) <span class="comment">// 提交给依赖收集器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里经历了一点小插曲。。在收集依赖定义中间变量currentEffect时想用下静态属性，一直报错(要么这个变量在类的外部定义就可以)，搜索一番后发现class的静态属性还只是个提案？还是我这node10版本太低了？那么，面向未来开发，<code>yarn global add typescript</code> + <code>yarn global add ts-node</code>一顿操作后运行<code>tsc --init</code>，然后在生成的json里修改指向es6：<code>&quot;target&quot;: &quot;es2015&quot;</code>，使用ts-node指令运行，代码结构还是那样，主要完善了在get set中收集和触发依赖，再运行测试用例，成功输出：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Test</span></span><br><span class="line">....</span><br><span class="line">等级提升： <span class="number">1</span></span><br><span class="line">等级提升： <span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="Reacticity响应式对象"><a href="#Reacticity响应式对象" class="headerlink" title="Reacticity响应式对象"></a>Reacticity响应式对象</h2><p>基本数据类型的reactive实现了，接下来实现对象的处理，还是上面vue3的例子，不同的是将导入的两个函数变成自己实现的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// const &#123; reactive, effect &#125; = require(&#x27;@vue/reactivity&#x27;)</span></span><br><span class="line"><span class="keyword">const</span> &#123; reactive, effect &#125; = <span class="built_in">require</span>(<span class="string">&#x27;./reactivity&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = reactive(&#123; <span class="attr">age</span>: <span class="number">1</span> &#125;) <span class="comment">// 创建了一个响应式的对象</span></span><br><span class="line"></span><br><span class="line">  .... 省略</span><br><span class="line"></span><br><span class="line">obj.age++ <span class="comment">// 操作对象，数据随之响应</span></span><br><span class="line"><span class="built_in">console</span>.log(_age, obj); <span class="comment">// 结果： 2 &#123; age: 2 &#125;</span></span><br></pre></td></tr></table></figure><p>那么现在就差reactive这个函数的实现了，继续上面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">    .... </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">effectWatch</span>(<span class="params">effect: Function</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 因为改成ts所以这里node环境也直接用es6的export了</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> effect = effectWatch</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">reactive</span>(<span class="params">target: any</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">        get(target: any, <span class="attr">key</span>: string | symbol) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key)</span><br><span class="line">        &#125;,</span><br><span class="line">        set(target: any, <span class="attr">key</span>: string | symbol, <span class="attr">value</span>: any) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码结构出来了，可以看出Proxy和Reflect其实没有那么神秘，有着同样的api参数使用也都一致，Proxy可以帮助解析对象，在这里实现了类似递归的效果，接下来就是要在Proxy中绑定Dep实例并且去触发依赖收集。先来定义一个函数存取实例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> targetMaps = <span class="keyword">new</span> <span class="built_in">Map</span>() <span class="comment">// 这里数据结构采用Map，因为用对象的话键名会被格式化成字符串</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDep</span>(<span class="params">target: any, key: string | symbol</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> deps = targetMaps.get(target) || <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">    targetMaps.set(target, deps)</span><br><span class="line">    <span class="keyword">const</span> dep = deps.get(key) || <span class="keyword">new</span> Dep()</span><br><span class="line">    deps.set(key, dep)</span><br><span class="line">    <span class="keyword">return</span> dep</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着就可以在reactive中使用getDep这个方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">reactive</span>(<span class="params">target: any</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">        get(target: any, <span class="attr">key</span>: string | symbol) &#123;</span><br><span class="line">            <span class="keyword">const</span> dep = getDep(target, key) <span class="comment">// 获取属性对应Dep实例</span></span><br><span class="line">            dep.depend() <span class="comment">// 触发收集依赖</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key)</span><br><span class="line">        &#125;,</span><br><span class="line">        set(target: any, <span class="attr">key</span>: string | symbol, <span class="attr">value</span>: any) &#123;</span><br><span class="line">            <span class="keyword">const</span> dep = getDep(target, key)</span><br><span class="line">            <span class="keyword">const</span> result = <span class="built_in">Reflect</span>.set(target, key, value)</span><br><span class="line">            result &amp;&amp; dep.notify() <span class="comment">// 数据有变化时去通知</span></span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上面改成导入自己包的测试用例，看看运行结果是否与Vue3的例子一致。</p><p>reactivity.ts 完整代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">    effects: any</span><br><span class="line">    val: any</span><br><span class="line">    <span class="keyword">constructor</span>(val: any = &#x27;&#x27;) &#123;</span><br><span class="line">        <span class="built_in">this</span>.effects = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">        <span class="built_in">this</span>.val = val</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title">value</span>() &#123;</span><br><span class="line">        <span class="built_in">this</span>.depend() <span class="comment">// get中开始收集依赖</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.val</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> <span class="title">value</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (newVal !== <span class="built_in">this</span>.val) &#123;</span><br><span class="line">            <span class="built_in">this</span>.val = newVal</span><br><span class="line">            <span class="built_in">this</span>.notify() <span class="comment">// 在set中触发通知</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    depend() &#123;</span><br><span class="line">        <span class="keyword">if</span> (Dep.currentEffect) &#123;</span><br><span class="line">            <span class="built_in">this</span>.effects.add(Dep.currentEffect)</span><br><span class="line">            Dep.currentEffect = <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    notify() &#123;</span><br><span class="line">        <span class="built_in">this</span>.effects.forEach(<span class="function">(<span class="params">effect: <span class="built_in">Function</span></span>) =&gt;</span> effect())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> currentEffect: any</span><br><span class="line">    <span class="keyword">static</span> trigger(e: <span class="built_in">Function</span>) &#123;</span><br><span class="line">        Dep.currentEffect = e</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">effectWatch</span>(<span class="params">effect: Function</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    effect() <span class="comment">// 模仿了vue3的effect函数，会先执行一次</span></span><br><span class="line">    Dep.trigger(effect)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> effect = effectWatch</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> targetMaps = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDep</span>(<span class="params">target: any, key: string | symbol</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> deps = targetMaps.get(target) || <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">    targetMaps.set(target, deps)</span><br><span class="line">    <span class="keyword">const</span> dep = deps.get(key) || <span class="keyword">new</span> Dep()</span><br><span class="line">    deps.set(key, dep)</span><br><span class="line">    <span class="keyword">return</span> dep</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">reactive</span>(<span class="params">target: any</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">        get(target: any, <span class="attr">key</span>: string | symbol) &#123;</span><br><span class="line">            <span class="keyword">const</span> dep = getDep(target, key)</span><br><span class="line">            dep.depend()</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key)</span><br><span class="line">        &#125;,</span><br><span class="line">        set(target: any, <span class="attr">key</span>: string | symbol, <span class="attr">value</span>: any) &#123;</span><br><span class="line">            <span class="keyword">const</span> dep = getDep(target, key)</span><br><span class="line">            <span class="keyword">const</span> result = <span class="built_in">Reflect</span>.set(target, key, value)</span><br><span class="line">            result &amp;&amp; dep.notify()</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始实现一个Vuex状态管理器</title>
      <link href="/2021/04/12/2021/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAVuex%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%99%A8/"/>
      <url>/2021/04/12/2021/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAVuex%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>先vue-cli工具直接创建一个项目，勾选Vuex，其他随意：</p><p><img src= "/img/loading__.gif" data-lazy-src="http://img.palxp.com/2021/04/1618157673623.png" alt="image.png"></p><p>创建完毕自动安装依赖，之后启动项目，熟悉的helloworld ~ 简单写个demo运行看看，后面会逐步实现一个myVuex，来达到相同的期望运行结果：</p><p><code>src/store/index.js</code> ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&quot;vuex&quot;</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    age: <span class="number">7</span></span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123; <span class="comment">// 不用多说</span></span><br><span class="line">    getAge(state) &#123; <span class="keyword">return</span> state.age &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123; <span class="comment">// vuex约定了对state的操作函数都放在这里，使用commit方法触发</span></span><br><span class="line">    changeAge(state, data) &#123;</span><br><span class="line">      state.age = data ? data : ++state.age</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123; <span class="comment">// vuex约定了异步类函数统一放在这里，dispatch方法触发</span></span><br><span class="line">    syncChangeAge(&#123; state, commit &#125;, data) &#123;</span><br><span class="line">      state.age = <span class="number">0</span></span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.commit(<span class="string">&#x27;changeAge&#x27;</span>, data) <span class="comment">// 这里我还没弄懂待会怎么实现&#123;commit&#125;的读取，在真实的Vuex中这里不加this也是可以运行的</span></span><br><span class="line">      &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  modules: &#123; <span class="comment">/** vuex的模块化，先不实现modules功能，就不挖坑了 */</span> &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>src/App.vue</code> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &#123;&#123; showMe &#125;&#125;</span><br><span class="line">    &lt;button @click&#x3D;&quot;$store.commit(&quot;changeAge&quot;)&quot;&gt;increase&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;button @click&#x3D;&quot;$store.dispatch(&quot;syncChangeAge&quot;, 7)&quot;&gt;reset&lt;&#x2F;button&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang&#x3D;&quot;js&quot;&gt;</span><br><span class="line">import Vue from &quot;vue&quot;;</span><br><span class="line">export default Vue.extend(&#123;</span><br><span class="line">  name: &quot;App&quot;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    showMe() &#123; return &#96;我今年$&#123;this.$store.getters.getAge || &quot;...&quot;&#125;岁了&#96;; &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>运行效果如下：</p><p><img src= "/img/loading__.gif" data-lazy-src="http://img.palxp.com/2021/04/1618159815068.png" alt="image.png"></p><p>说明：点击增加按钮加一岁，点击重置按钮进入loading状态1秒后又设置为7岁，现在，把stroe中引入的<code>import Vuex from &quot;vuex&quot;;</code>改为自己的手动实现，达到跟这个demo一致的运行效果。</p><h2 id="Ready-Perfect"><a href="#Ready-Perfect" class="headerlink" title="Ready Perfect"></a>Ready Perfect</h2><p>开始前还是先写出代码结构，创建 <code>Vuex</code> 文件夹，写入第一个index文件。</p><p><code>src/Vuex/index.js</code> ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(parameters) &#123; <span class="comment">// vuex的核心四件套</span></span><br><span class="line">        <span class="built_in">this</span>.state = &#123;&#125;</span><br><span class="line">        <span class="built_in">this</span>.getters = &#123;&#125;</span><br><span class="line">        <span class="built_in">this</span>.mutations = &#123;&#125;</span><br><span class="line">        <span class="built_in">this</span>.actions = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title">state</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.state</span><br><span class="line">    &#125;</span><br><span class="line">    commit(fName, data) &#123;</span><br><span class="line">        <span class="built_in">this</span>.mutations[fName].forEach(<span class="function"><span class="params">mutation</span> =&gt;</span> mutation(data));</span><br><span class="line">    &#125;</span><br><span class="line">    dispatch(fName, data) &#123;</span><br><span class="line">        <span class="built_in">this</span>.actions[fName].forEach(<span class="function"><span class="params">action</span> =&gt;</span> action(data));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123; Store &#125;</span><br></pre></td></tr></table></figure><p>这样vuex的简单结构就写完了，接下来处理对实例传入的mutation和action的收集，然后提供commit和dispatch函数来执行。</p><h2 id="创建-install"><a href="#创建-install" class="headerlink" title="创建 install"></a>创建 install</h2><p>首先 store 中先是调用了 <code>Vue.use(Vuex)</code>，让状态管理器注入到vue中，此时需要用到混入。</p><p>mixin 参考：<a href="https://cn.vuejs.org/v2/guide/mixins.html#%E5%85%A8%E5%B1%80%E6%B7%B7%E5%85%A5">vue全局混入</a></p><p>根据vue文档描述，使用use必须提供一个install函数，Vue会作为参数传入，参考：<a href="https://cn.vuejs.org/v2/api/#Vue-use">vueUse</a></p><p><code>src/Vuex/index.js</code> ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> install = <span class="function">(<span class="params">Vue</span>) =&gt;</span> &#123;</span><br><span class="line">    Vue.mixin(&#123;</span><br><span class="line">        beforeCreate() &#123;</span><br><span class="line">            <span class="keyword">const</span> &#123; store = <span class="literal">null</span> &#125; = <span class="built_in">this</span>.$options</span><br><span class="line">            <span class="keyword">if</span> (store) &#123;</span><br><span class="line">                <span class="built_in">this</span>.$store = store</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.$store = <span class="built_in">this</span>.$parent &amp;&amp; <span class="built_in">this</span>.$parent.$store</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123; Store, install &#125;</span><br></pre></td></tr></table></figure><h2 id="绑定-state"><a href="#绑定-state" class="headerlink" title="绑定 state"></a>绑定 state</h2><p>在上一步创建install时引入了Vue，将其挂载到全局来创建一个实例对象，利用Vue中数据双向绑定来实现state：</p><p><code>src/Vuex/index.js</code> ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> _Vue</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(parameters) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; state = &#123; &#125; &#125; = parameters</span><br><span class="line">        <span class="built_in">this</span>.$vue = <span class="keyword">new</span> _Vue(&#123; <span class="comment">// new一个Vue实例接收用户传进的state</span></span><br><span class="line">            data: &#123; state &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title">state</span>() &#123; <span class="comment">// 抛出Vue实例上挂载的 state</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.$vue.state</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> install = <span class="function">(<span class="params">Vue</span>) =&gt;</span> &#123;</span><br><span class="line">    _Vue = Vue</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line">.....</span><br></pre></td></tr></table></figure><h2 id="处理-getter"><a href="#处理-getter" class="headerlink" title="处理 getter"></a>处理 getter</h2><p>继续上面的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">....</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(parameters) &#123;</span><br><span class="line">        .....</span><br><span class="line">        bindInstall(<span class="built_in">this</span>, parameters)</span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> install = <span class="function">(<span class="params">Vue</span>) =&gt;</span> &#123; .... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bindInstall = <span class="function">(<span class="params">store, options</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 处理getters</span></span><br><span class="line">    <span class="keyword">const</span> &#123; getters &#125; = options</span><br><span class="line">    <span class="keyword">if</span> (getters) &#123;</span><br><span class="line">        <span class="built_in">Object</span>.keys(getters).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">Object</span>.defineProperty(store.getters, key, &#123;</span><br><span class="line">                get() &#123;</span><br><span class="line">                    <span class="keyword">return</span> getters[key](options.state)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123; Store, install &#125;</span><br></pre></td></tr></table></figure><p>到这里，可以将 <code>src/store/index</code> 中的引入改成我们自己的了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import Vuex from &quot;vuex&quot;;</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&quot;../Vuex&quot;</span>;</span><br><span class="line">.....</span><br></pre></td></tr></table></figure><p>将例子运行，将看到已经成功拿到store中的getter，继续完善</p><h2 id="处理-mutations-与-actions"><a href="#处理-mutations-与-actions" class="headerlink" title="处理 mutations 与 actions"></a>处理 mutations 与 actions</h2><p>继续完善刚才的bindInstall代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">....</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123; ..... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> install = <span class="function">(<span class="params">Vue</span>) =&gt;</span> &#123; .... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bindInstall = <span class="function">(<span class="params">store, options</span>) =&gt;</span> &#123; <span class="comment">// 两边收集都比较相似</span></span><br><span class="line">    <span class="keyword">const</span> &#123; getters, mutations, actions &#125; = options</span><br><span class="line">    <span class="keyword">if</span> (getters) &#123; ... &#125;</span><br><span class="line">    <span class="keyword">if</span> (mutations) &#123;</span><br><span class="line">        <span class="built_in">Object</span>.keys(mutations).forEach(<span class="function"><span class="params">mutationName</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> storeMutations = store.mutations[mutationName] || []</span><br><span class="line">            storeMutations.push(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">                mutations[mutationName].call(store, store.state, data) <span class="comment">// mutations中的函数第一个参数是state，第二个是值</span></span><br><span class="line">            &#125;)</span><br><span class="line">            store.mutations[mutationName] = storeMutations</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (actions) &#123;</span><br><span class="line">        <span class="built_in">Object</span>.keys(actions).forEach(<span class="function"><span class="params">actionName</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> storeActions = store.actions[actionName] || []</span><br><span class="line">            storeActions.push(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">                actions[actionName].call(store, store, data) <span class="comment">// 这里我第一个参数先直接返回了实例对象，还不知道如何实现vuex中的效果</span></span><br><span class="line">            &#125;)</span><br><span class="line">            store.actions[actionName] = storeActions</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123; Store, install &#125;</span><br></pre></td></tr></table></figure><p>保存，运行测试 - 和最初的demo结果一致，至此实现了核心的vuex状态管理器</p><p>以下是 <code>Vuex/index.js</code> 完整代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> _Vue</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(parameters) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; state = &#123;&#125; &#125; = parameters</span><br><span class="line">        <span class="built_in">this</span>.$vue = <span class="keyword">new</span> _Vue(&#123; <span class="attr">data</span>: &#123; state &#125; &#125;)</span><br><span class="line">        <span class="built_in">this</span>.getters = &#123;&#125;</span><br><span class="line">        <span class="built_in">this</span>.mutations = &#123;&#125;</span><br><span class="line">        <span class="built_in">this</span>.actions = &#123;&#125;</span><br><span class="line">        bindInstall(<span class="built_in">this</span>, parameters)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title">state</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.$vue.state</span><br><span class="line">    &#125;</span><br><span class="line">    commit(fName, data) &#123;</span><br><span class="line">        <span class="built_in">this</span>.mutations[fName].forEach(<span class="function"><span class="params">mutation</span> =&gt;</span> mutation(data));</span><br><span class="line">    &#125;</span><br><span class="line">    dispatch(fName, data) &#123;</span><br><span class="line">        <span class="built_in">this</span>.actions[fName].forEach(<span class="function"><span class="params">action</span> =&gt;</span> action(data));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> install = <span class="function">(<span class="params">Vue</span>) =&gt;</span> &#123;</span><br><span class="line">    _Vue = Vue</span><br><span class="line">    Vue.mixin(&#123;</span><br><span class="line">        beforeCreate() &#123;</span><br><span class="line">            <span class="keyword">const</span> &#123; store = <span class="literal">null</span> &#125; = <span class="built_in">this</span>.$options</span><br><span class="line">            <span class="keyword">if</span> (store) &#123;</span><br><span class="line">                <span class="built_in">this</span>.$store = store</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.$store = <span class="built_in">this</span>.$parent &amp;&amp; <span class="built_in">this</span>.$parent.$store</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bindInstall = <span class="function">(<span class="params">store, options</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; getters, mutations, actions &#125; = options</span><br><span class="line">    <span class="keyword">if</span> (getters) &#123;</span><br><span class="line">        <span class="built_in">Object</span>.keys(getters).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">Object</span>.defineProperty(store.getters, key, &#123;</span><br><span class="line">                get() &#123;</span><br><span class="line">                    <span class="keyword">return</span> getters[key](options.state)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mutations) &#123;</span><br><span class="line">        <span class="built_in">Object</span>.keys(mutations).forEach(<span class="function"><span class="params">mutationName</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> storeMutations = store.mutations[mutationName] || []</span><br><span class="line">            storeMutations.push(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">                mutations[mutationName].call(store, store.state, data)</span><br><span class="line">            &#125;)</span><br><span class="line">            store.mutations[mutationName] = storeMutations</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (actions) &#123;</span><br><span class="line">        <span class="built_in">Object</span>.keys(actions).forEach(<span class="function"><span class="params">actionName</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> storeActions = store.actions[actionName] || []</span><br><span class="line">            storeActions.push(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">                actions[actionName].call(store, store, data)</span><br><span class="line">            &#125;)</span><br><span class="line">            store.actions[actionName] = storeActions</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123; Store, install &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始基于React服务端渲染&amp;同构</title>
      <link href="/2021/04/12/2021/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%9F%BA%E4%BA%8EReact%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93-%E5%90%8C%E6%9E%84/"/>
      <url>/2021/04/12/2021/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%9F%BA%E4%BA%8EReact%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93-%E5%90%8C%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h3 id="1-概念分析："><a href="#1-概念分析：" class="headerlink" title="1. 概念分析："></a>1. 概念分析：</h3><p>服务端渲染（SSR）</p><ul><li>更好的⾸屏性能</li><li>更利于 SEO，爬虫可以直接抓取已渲染的内容</li></ul><p>客户端渲染</p><ul><li>前后分离，⻚⾯的交互</li></ul><p>同构：服务端和客户端都可以运⾏的同⼀套代码</p><ul><li>同一套代码，复用率，可维护性增强</li><li>同时具有SSR与前后端分离的优势，利于 SEO 优化</li><li>更好的性能与更好的用户体验</li></ul><h3 id="2-架构思路及要点"><a href="#2-架构思路及要点" class="headerlink" title="2. 架构思路及要点"></a>2. 架构思路及要点</h3><p>React提供了服务器渲染的各种API，可快速满足同构需求。<br>同一份代码要在服务端与客户端各执行一次，首屏加载完服务端渲染的页面后，客户端紧接着继续执行并重新渲染页面，接管后续的页面交互。</p><h3 id="3-同构关键点"><a href="#3-同构关键点" class="headerlink" title="3. 同构关键点"></a>3. 同构关键点</h3><p>所谓同一份代码同时运行服务端和客户端，其实可复用的基本为组件，服务端与客户端的差异无法完全被抹平，而React的好处就是对服务端构建提供了不少解决方案。</p><h4 id="1-路由不同"><a href="#1-路由不同" class="headerlink" title="1. 路由不同"></a>1. 路由不同</h4><p>客户端使用：<code>&lt;BrowserRouter /&gt;</code>    服务端使用：<code>&lt;StaticRouter /&gt;</code></p><h4 id="2-代码的同构"><a href="#2-代码的同构" class="headerlink" title="2. 代码的同构"></a>2. 代码的同构</h4><p><img src= "/img/loading__.gif" data-lazy-src="http://img.palxp.com/2021/04/1618049055459.png" alt="image.png"></p><p>接下来我们将尝试一步步从零开始实现一个React同构项目Demo。</p><blockquote><p>文章参考：<br><a href="https://imweb.io/topic/5d2da910b17a4bd24bd0678a">https://imweb.io/topic/5d2da910b17a4bd24bd0678a</a><br><a href="https://www.jianshu.com/p/c98f44026ec6">https://www.jianshu.com/p/c98f44026ec6</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>40行代码实现一个简单Promise函数</title>
      <link href="/2021/04/04/2021/%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA-Promise%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
      <url>/2021/04/04/2021/%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA-Promise%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>一个遵循<a href="https://promisesaplus.com/">PromiseA+规范</a>的函数，解决异步回调地狱问题。</p></blockquote><h2 id="Promise主要特点"><a href="#Promise主要特点" class="headerlink" title="Promise主要特点"></a>Promise主要特点</h2><ol><li>Promise 会有三种状态，「进⾏中」「已完成」和「已拒绝」，进⾏中状态可以更改为已完成或已拒绝，已经更改过状态后<strong>⽆法继续更改</strong>（例如从已完成改为已拒绝）。</li><li>Promise 构造之后需要传⼊⼀个函数，它接受<strong>两个参数</strong>，执⾏第⼀个参数之后就会改变当前 promise 为「已完成」状态，执⾏ 第⼆个参数之后就会变为「已拒绝」状态。</li><li>通过 <code>.then</code> ⽅法，即可在上⼀个 promise 达到已完成 时继续执⾏下⼀个函数或 promise。同时通过 resolve 或 reject 时传⼊参数，即可给下⼀个函数或 promise 传⼊初始值。</li><li>已拒绝的 promise，后续可以通过 .catch ⽅法或是 .then ⽅法的第⼆个参数或是 try catch 进⾏捕获。</li></ol><h2 id="结构梳理"><a href="#结构梳理" class="headerlink" title="结构梳理"></a>结构梳理</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">simplePromise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(handleFn) &#123; <span class="comment">// 构造时传入一个函数</span></span><br><span class="line">        <span class="built_in">this</span>.status = <span class="string">&#x27;pending&#x27;</span> <span class="comment">// 有三个状态</span></span><br><span class="line">        handleFn(resolve, reject) <span class="comment">// 该函数接收两个参数</span></span><br><span class="line">    &#125;</span><br><span class="line">    then() &#123; <span class="comment">// 它有一个then方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> simplePromise(<span class="function">() =&gt;</span> &#123; <span class="comment">// 返回的是promise实例then才得以串联起来</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="string">&#x27;pending&#x27;</span>) &#123; <span class="comment">// 状态一旦改变不可修改</span></span><br><span class="line">                <span class="comment">// TODO</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 一些静态方法</span></span><br><span class="line">    <span class="keyword">catch</span>() &#123;&#125;</span><br><span class="line">    resolve() &#123;&#125;</span><br><span class="line">    reject() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现resolve"><a href="#实现resolve" class="headerlink" title="实现resolve"></a>实现resolve</h2><p>这是Promise的第一个关键点，主要在于逻辑的判断，如何将then串联起来，以及最后收集依赖</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimplePromise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(handleFn) &#123;</span><br><span class="line">        <span class="built_in">this</span>.status = <span class="string">&#x27;pending&#x27;</span> <span class="comment">// 标记状态</span></span><br><span class="line">        <span class="built_in">this</span>.fulfilledList = [] <span class="comment">// 任务队列</span></span><br><span class="line">        handleFn(<span class="function"><span class="params">params</span> =&gt;</span> &#123; &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    then(onFulfilled, onRejected) &#123; <span class="comment">// then()接收两个函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimplePromise(<span class="function">(<span class="params">onNextFulfilled, onNextRejected</span>) =&gt;</span> &#123; <span class="comment">// 返回一个Promise</span></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">finalFn</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">typeof</span> onFulfilled !== <span class="string">&#x27;function&#x27;</span>) &#123; <span class="comment">// 如果不是函数，跳过执行下一步</span></span><br><span class="line">                    onNextFulfilled(params)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">const</span> res = onFulfilled(params) <span class="comment">// 如果是函数，先接收其返回结果</span></span><br><span class="line">                    <span class="keyword">if</span> (res &amp;&amp; res <span class="keyword">instanceof</span> SimplePromise) &#123; <span class="comment">// 判断是否为Promise，也可以判断有没有then方法typeof res.then === &#x27;function&#x27;</span></span><br><span class="line">                        res.then(onNextFulfilled) <span class="comment">// 继续执行Promise</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        onNextFulfilled(res) <span class="comment">// 不是Promise继续执行下一步</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.fulfilledList.push(finalFn) <span class="comment">// 收集依赖</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个关键点在于，用户传入的函数，在构造时会立即执行，但收集依赖是在then方法中，所以需要将传入的函数放到异步队列中去执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimplePromise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(handleFn) &#123;</span><br><span class="line">        <span class="built_in">this</span>.status = <span class="string">&#x27;pending&#x27;</span> <span class="comment">// 标记状态</span></span><br><span class="line">        <span class="built_in">this</span>.fulfilledList = [] <span class="comment">// 任务队列</span></span><br><span class="line">        handleFn(<span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">// 抛进异步队列，保证不会立即执行</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.status !== <span class="string">&#x27;pending&#x27;</span>) &#123; <span class="keyword">return</span> &#125; <span class="comment">// 状态一旦确定再无法变更</span></span><br><span class="line">                <span class="built_in">this</span>.status = <span class="string">&#x27;fulfilled&#x27;</span> <span class="comment">// 执行就改变状态</span></span><br><span class="line">                <span class="built_in">this</span>.fulfilledList.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn(val))<span class="comment">// 开始执行函数</span></span><br><span class="line">                <span class="built_in">this</span>.fulfilledList = [] <span class="comment">// 释放</span></span><br><span class="line">            &#125;, <span class="number">0</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    then(onFulfilled, onRejected) &#123; ..... &#125;</span><br><span class="line">    <span class="keyword">catch</span>() &#123; &#125;</span><br><span class="line">    resolve() &#123; &#125;</span><br><span class="line">    reject() &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接下来将reject也实现进去，handleFn为用户传入的函数，其接收两个参数resolve和reject，我们分别执行了两个队列里收集的任务。</li><li>而then中则创建了一个工厂函数，用于生成两种收集依赖的方法。</li></ul><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimplePromise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(handleFn) &#123;</span><br><span class="line">        <span class="built_in">this</span>.status = <span class="string">&#x27;pending&#x27;</span> <span class="comment">// 标记状态</span></span><br><span class="line">        <span class="built_in">this</span>.fulfilledList = [] <span class="comment">// 任务队列</span></span><br><span class="line">        <span class="built_in">this</span>.rejectedList = []</span><br><span class="line">        handleFn(<span class="built_in">this</span>.trigger.bind(<span class="built_in">this</span>, <span class="string">&#x27;fulfilled&#x27;</span>), <span class="built_in">this</span>.trigger.bind(<span class="built_in">this</span>, <span class="string">&#x27;rejected&#x27;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    trigger(status, val) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">// 抛进异步队列，保证不会立即执行</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.status !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>; <span class="comment">// 状态一旦确定再无法变更</span></span><br><span class="line">            <span class="built_in">this</span>.status = status <span class="comment">// 状态变更</span></span><br><span class="line">            <span class="built_in">this</span>[<span class="string">`<span class="subst">$&#123;status&#125;</span>List`</span>].forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn(val)) <span class="comment">// 开始执行函数</span></span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    then(onFulfilled, onRejected) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimplePromise(<span class="function">(<span class="params">onNextFulfilled, onNextRejected</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">createFinalFn</span>(<span class="params">prev, next</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">params</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">typeof</span> prev !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">                        next(params)</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">const</span> res = prev(params)</span><br><span class="line">                        res &amp;&amp; res <span class="keyword">instanceof</span> SimplePromise ? res.then(next) : next(res)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.fulfilledList.push(createFinalFn(onFulfilled, onNextFulfilled))</span><br><span class="line">                <span class="built_in">this</span>.rejectedList.push(createFinalFn(onRejected, onNextRejected))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(onRejected) &#123; <span class="comment">// 返回reject</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">null</span>, onRejected)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> resolve(val) &#123; <span class="comment">// 直接成功执行的结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimplePromise(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(val))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> reject(val) &#123; <span class="comment">// 暴露出失败结果，或许可以用来做Promise的中断</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimplePromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(val))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此大概40行的代码实现了一个简单的Promise，写个例子测试下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> SimplePromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;success&#x27;</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;ok&#x27;</span>, res)</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;no&#x27;</span>, err)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// ok success</span></span><br></pre></td></tr></table></figure><p>本例中实现的简单Promise无法跑通全部官方测试用例，只是对实现规范中的核心部分进行一次编写练习。</p><p>最后用上SimplePromise来运行一道据说来自网易的面试题加深对Promise的认识</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> SimplePromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">1</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> SimplePromise.resolve(<span class="number">2</span>);</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;第一题&#x27;</span>,n)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">&#125;).then(<span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;第二题&#x27;</span>,n)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="number">2</span>).then(<span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;第三题&#x27;</span>,n)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>输出结果：<br>    第二题 2<br>    第三题 1<br>    第一题 2</p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一起写几个JS函数（call、防抖节流）</title>
      <link href="/2021/04/03/2021/%E8%A7%A3%E6%9E%90%E5%87%A0%E4%B8%AAJS%E6%89%8B%E5%86%99%E5%87%BD%E6%95%B0%EF%BC%88call%E3%80%81%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81%EF%BC%89/"/>
      <url>/2021/04/03/2021/%E8%A7%A3%E6%9E%90%E5%87%A0%E4%B8%AAJS%E6%89%8B%E5%86%99%E5%87%BD%E6%95%B0%EF%BC%88call%E3%80%81%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="call函数"><a href="#call函数" class="headerlink" title="call函数"></a>call函数</h2><p>先从改变this指向上简单实现一个方法添加到Function的原型链上：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params">content</span>) </span>&#123;</span><br><span class="line">    content.fn = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="built_in">eval</span>(<span class="string">`content.fn()`</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就实现了call函数核心部分，因为使用了字符串的形式，所以函数的参数部分还需要进行特殊处理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params">content</span>) </span>&#123;</span><br><span class="line">    content.fn = <span class="built_in">this</span></span><br><span class="line">    <span class="comment">/** 处理参数 */</span></span><br><span class="line">    <span class="keyword">const</span> args = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">        args.push(<span class="string">`arguments[<span class="subst">$&#123;i&#125;</span>]`</span>) <span class="comment">// 直接push会导致强转字符串时出现:[]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** */</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="built_in">eval</span>(<span class="string">`content.fn(<span class="subst">$&#123;args&#125;</span>)`</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本可以了，但还有问题，临时属性的处理，最终优化结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params">content</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> fn = <span class="string">`fn_<span class="subst">$&#123;(<span class="built_in">Math</span>.random()*<span class="number">999</span>).toFixed()&#125;</span>`</span> <span class="comment">// 防止极端情况下属性名冲突</span></span><br><span class="line">    content[fn] = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">const</span> args = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">        args.push(<span class="string">`arguments[<span class="subst">$&#123;i&#125;</span>]`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="built_in">eval</span>(<span class="string">`content[fn](<span class="subst">$&#123;args&#125;</span>)`</span>)</span><br><span class="line">    <span class="keyword">delete</span> content[fn] <span class="comment">// 使用后释放</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写个例子测试下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">    name: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">    say: <span class="function"><span class="keyword">function</span> (<span class="params">t</span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;t&#125;</span>, <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> b = &#123; <span class="attr">name</span>: <span class="string">&#x27;b&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line">a.say.call(b, <span class="string">&#x27;hi&#x27;</span>) <span class="comment">// hi, b</span></span><br><span class="line">a.say.myCall(b, <span class="string">&#x27;hello&#x27;</span>) <span class="comment">// hello, b</span></span><br></pre></td></tr></table></figure><h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><p>以滚动事件为例，防抖即是滚动过程中低频率地触发事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onscroll = throttle(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;throttle&#x27;</span>); <span class="comment">// 持续滚动只会间隔1s有节奏地执行打印</span></span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>定时器throttle实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay = <span class="number">1000</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">            timer = <span class="literal">null</span>; <span class="comment">// 闭包，释放timer</span></span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间戳throttle实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delayTime = <span class="number">1000</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> lastTime = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> nowTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line">        <span class="keyword">if</span> (nowTime - lastTime &gt; delayTime) &#123;</span><br><span class="line">            fn.call(<span class="built_in">this</span>, ...arguments)</span><br><span class="line">            lastTime = nowTime <span class="comment">// 也是闭包，维护一个时间戳</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p>还是以滚动事件为例，节流即是滚动过程中只触发一次事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onscroll = debounce(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;debounce&#x27;</span>); <span class="comment">// 直到完全停止滚动后1s才执行输出</span></span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>定时器debounce实现，与防抖就是一个模子刻出来的，不同的是节流不会多次执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay = <span class="number">1000</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(timer) <span class="comment">// 与防抖的主要区别，前面的任务清除，只保留最后一次执行</span></span><br><span class="line">        &#125;</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            fn.call(<span class="built_in">this</span>, ...arguments)</span><br><span class="line">            timer = <span class="literal">null</span></span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 前端巩固 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS面向对象编程及原型继承全面解析</title>
      <link href="/2021/03/29/2021/%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%8F%8A%E5%8E%9F%E5%9E%8B%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF/"/>
      <url>/2021/03/29/2021/%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%8F%8A%E5%8E%9F%E5%9E%8B%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="面向对象编程的特点"><a href="#面向对象编程的特点" class="headerlink" title="面向对象编程的特点"></a>面向对象编程的特点</h2><ol><li>封装：使用对象的人<strong>无需考虑内部实现</strong>，只考虑功能的使用。</li><li>继承：为了代码的可<strong>复用</strong>。</li><li>多态：不同对象 作用于<strong>同一操作</strong>产生不同结果。</li></ol><h2 id="JS如何创建对象"><a href="#JS如何创建对象" class="headerlink" title="JS如何创建对象"></a>JS如何创建对象</h2><h3 id="普通方式"><a href="#普通方式" class="headerlink" title="普通方式"></a>普通方式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> A = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">A.attribute = <span class="string">&#x27;&#x27;</span> <span class="comment">// 定义属性</span></span><br><span class="line">A.fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; &#125; <span class="comment">// 定义方法</span></span><br></pre></td></tr></table></figure><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Creat</span>(<span class="params">attr</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// .... 同上面普通方式 </span></span><br><span class="line">    <span class="keyword">return</span> A</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> aa = Creat(<span class="string">&#x27;...&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> bb = Creat(<span class="string">&#x27;...&#x27;</span>)</span><br></pre></td></tr></table></figure><p>存在问题：往实例化对象上层找不到父类，只能知道是一个Object</p><h3 id="构造函数-实例"><a href="#构造函数-实例" class="headerlink" title="构造函数/实例"></a>构造函数/实例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Player</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;...&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x = <span class="keyword">new</span> Player(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> y = <span class="keyword">new</span> Player(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(x.run === y.run) <span class="comment">// false 独立内存</span></span><br></pre></td></tr></table></figure><p>缺点：通过this添加的属性和方法，总是指向当前对象（改变当前对象不会影响构造函数），实例化时通过this添加的属性和方法都会在内存当中复制一份。</p><h3 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Player</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line">Player.prototype.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;...&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x = <span class="keyword">new</span> Player(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> y = <span class="keyword">new</span> Player(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(x.run === y.run) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Player</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    Player.count = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Player(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p.count) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(Player.count) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h2 id="原型及原型链"><a href="#原型及原型链" class="headerlink" title="原型及原型链"></a>原型及原型链</h2><h3 id="查找原型对象的方法"><a href="#查找原型对象的方法" class="headerlink" title="查找原型对象的方法"></a>查找原型对象的方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xxx.__proto__</span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(xxx)</span><br></pre></td></tr></table></figure><h3 id="new关键字做了什么"><a href="#new关键字做了什么" class="headerlink" title="new关键字做了什么"></a>new关键字做了什么</h3><ol><li>创建了新对象并将.__proto__指向构造函数的.prototype</li><li>将this指向新创建的对象</li><li>返回新对象（1. 有显式的返回值且是对象则返回这个对象 2. 其他情况返回this）</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newSimulator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建新对象</span></span><br><span class="line">    <span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">    <span class="comment">// 2. 设置__proto__为构造函数prototype</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">constructor</span> = [].shift.call(arguments) // 取出参数第一项，并删除掉，剩余参数在下一步会用到</span><br><span class="line">    obj.__proto__ = <span class="keyword">constructor</span>.prototype</span><br><span class="line">    // 3. this指向新对象，也就是改变this的指向：例如apply，call</span><br><span class="line">    const ret = <span class="keyword">constructor</span>.apply(obj, arguments)</span><br><span class="line">    // 4. 返回新对象或this</span><br><span class="line">    return typeof ret === &#x27;object&#x27; ? ret : obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Player</span>(<span class="params">name, type</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.say = <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">`i am <span class="subst">$&#123;name&#125;</span>,i create by <span class="subst">$&#123;type&#125;</span>`</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> Player(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;new&#x27;</span>)</span><br><span class="line">a.say() <span class="comment">// i am a,i create by new</span></span><br><span class="line"><span class="keyword">const</span> b = newSimulator(Player, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;newSimulator&#x27;</span>)</span><br><span class="line">b.say() <span class="comment">// i am b,i create by newSimulator</span></span><br></pre></td></tr></table></figure><h3 id="理解原型链"><a href="#理解原型链" class="headerlink" title="理解原型链"></a>理解原型链</h3><p>当读取实例对象的属性时，如果找不到，会查找对象原型中的属性，直到最上层为止。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.name = <span class="string">&#x27;Object&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Player</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Player.prototype.name = <span class="string">&#x27;Player&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Player();</span><br><span class="line">p1.name = <span class="string">&#x27;p1&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(p1.name); <span class="comment">// p1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> p1.name;</span><br><span class="line"><span class="built_in">console</span>.log(p1.name); <span class="comment">// Player</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> Player.prototype.name;</span><br><span class="line"><span class="built_in">console</span>.log(p1.name); <span class="comment">// Object</span></span><br></pre></td></tr></table></figure><h2 id="JS实现继承"><a href="#JS实现继承" class="headerlink" title="JS实现继承"></a>JS实现继承</h2><h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;ParentName&#x27;</span>;</span><br><span class="line">    <span class="built_in">this</span>.actions = [<span class="string">&#x27;sing&#x27;</span>, <span class="string">&#x27;jump&#x27;</span>, <span class="string">&#x27;rap&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent(); <span class="comment">// 通过实例化对象来拿到全部属性方法</span></span><br><span class="line">Child.prototype.constructor = Child; <span class="comment">// 但是直接赋值会覆盖掉Child，这一步是其将修改回来</span></span><br></pre></td></tr></table></figure><p>存在问题：引用类型被改变，所有实例共享，无法传参</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> c1 = <span class="keyword">new</span> Child();</span><br><span class="line">c1.actions.push(<span class="string">&#x27;basketball&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(c1.actions); <span class="comment">//[ &#x27;sing&#x27;, &#x27;jump&#x27;, &#x27;rap&#x27;, &#x27;basketball&#x27; ]</span></span><br><span class="line"><span class="keyword">const</span> c2 = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="built_in">console</span>.log(c2.actions); <span class="comment">// [ &#x27;sing&#x27;, &#x27;jump&#x27;, &#x27;rap&#x27;, &#x27;basketball&#x27; ]</span></span><br></pre></td></tr></table></figure><h3 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.actions = [<span class="string">&#x27;sing&#x27;</span>, <span class="string">&#x27;jump&#x27;</span>, <span class="string">&#x27;rap&#x27;</span>];</span><br><span class="line">    <span class="built_in">this</span>.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    Parent.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>); <span class="comment">// 把Parent执行了一遍，解决了传参问题</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> c1 = <span class="keyword">new</span> Child(<span class="string">&#x27;c1&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> c2 = <span class="keyword">new</span> Child(<span class="string">&#x27;c2&#x27;</span>);</span><br><span class="line">c1.actions.pop() <span class="comment">// 引用类型的问题被解决</span></span><br><span class="line"><span class="built_in">console</span>.log(c1.name, c1.actions) <span class="comment">// c1 [ &#x27;sing&#x27;, &#x27;jump&#x27; ]</span></span><br><span class="line"><span class="built_in">console</span>.log(c2.name, c2.actions) <span class="comment">// c2 [ &#x27;sing&#x27;, &#x27;jump&#x27;, &#x27;rap&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(c1.say === c2.say); <span class="comment">// false 独立内存，构造函数的问题，消耗大</span></span><br></pre></td></tr></table></figure><h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>该继承同时解决以上两种继承存在的问题，副作用是会重复执行构造函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 即原型链继承 + 构造函数继承</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name, actions</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.actions = actions;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27; say&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    Parent.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>); <span class="comment">// 第一次调用构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent(); <span class="comment">// 第二次调用构造函数</span></span><br><span class="line">Child.prototype.constructor = Child;</span><br><span class="line"><span class="comment">// 组合继承中到这一步，是使用到开头原型链继承的方式，可以看做它将Child中的原型链方法变成了引用类型</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> c1 = <span class="keyword">new</span> Child(<span class="string">&#x27;c1&#x27;</span>, [<span class="string">&#x27;eat&#x27;</span>]);</span><br><span class="line"><span class="keyword">const</span> c2 = <span class="keyword">new</span> Child(<span class="string">&#x27;c2&#x27;</span>, [<span class="string">&#x27;run&#x27;</span>]);</span><br><span class="line">c1.actions.pop() <span class="comment">// 引用类型的问题被解决</span></span><br><span class="line"><span class="built_in">console</span>.log(c1.name, c1.actions) <span class="comment">// c1 []</span></span><br><span class="line"><span class="built_in">console</span>.log(c2.name, c2.actions) <span class="comment">// c2 [ &#x27;run&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(c1.say === c2.say); <span class="comment">// true 内存消耗问题被解决</span></span><br></pre></td></tr></table></figure><h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 还是刚才的组合继承，改变的地方会被注释</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name, actions</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.actions = actions;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.say + <span class="string">&#x27; say&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    Parent.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Child.prototype = new Parent();</span></span><br><span class="line">Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype);</span><br><span class="line">Child.prototype.constructor = Child;</span><br></pre></td></tr></table></figure><p>解析其中 <code>Object.create</code> 等于以下写法(es5)：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> TempFunction = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// 一个空的临时变量</span></span><br><span class="line">TempFunction.prototype = Parent.prototype; <span class="comment">// 将临时函数的原型指向Parent的原型</span></span><br><span class="line">Child.prototype = <span class="keyword">new</span> TempFunction(); <span class="comment">// 这样就同样实现了原型链继承的优点，并且开销极低</span></span><br></pre></td></tr></table></figure><p>这也就是“寄生”的含义：用一个纯粹的中间函数去执行了new。</p><h3 id="es6继承"><a href="#es6继承" class="headerlink" title="es6继承"></a>es6继承</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&#x27;aaa&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    say() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name, <span class="string">&#x27;say&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写到es6已经完全不需要说什么了，一句话总结：JS，面向未来编程😋</p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 前端巩固 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一次搞懂前端this、闭包、作用域</title>
      <link href="/2021/03/29/2021/%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA-this%E3%80%81%E9%97%AD%E5%8C%85%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
      <url>/2021/03/29/2021/%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA-this%E3%80%81%E9%97%AD%E5%8C%85%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h2><blockquote><p>闭包是指有权访问另外一个函数作用域中的变量的函数.可以理解为(能够读取其他函数内部变量的函数)</p></blockquote><h4 id="0-封装私有变量"><a href="#0-封装私有变量" class="headerlink" title="0. 封装私有变量"></a>0. 封装私有变量</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person0</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>._attackVolume = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line">Person0.prototype = &#123;</span><br><span class="line">    <span class="comment">/** ... **/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> p0 = <span class="keyword">new</span> Person0(); <span class="built_in">console</span>.log(p0._attackVolume); <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _attackVolume = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        attack() &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;attack &#x27;</span> + _attackVolume);</span><br><span class="line">            _attackVolume++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person1(); <span class="built_in">console</span>.log(p1._attackVolume); <span class="comment">// undefined</span></span><br><span class="line">p1.attack() <span class="comment">// attack 101</span></span><br><span class="line">p1.attack() <span class="comment">// attack 100</span></span><br></pre></td></tr></table></figure><h4 id="1-储存变量-缓存"><a href="#1-储存变量-缓存" class="headerlink" title="1. 储存变量(缓存)"></a>1. 储存变量(缓存)</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getListDataManager</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> localData = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        getData() &#123;</span><br><span class="line">            <span class="keyword">if</span> (localData) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(localData); <span class="comment">// 返回的是储存的结果</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> fetch(<span class="string">&#x27;xxxx&#x27;</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> localData = data.json()); <span class="comment">// 真实的数据请求</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-防抖节流函数的实现"><a href="#2-防抖节流函数的实现" class="headerlink" title="2. 防抖节流函数的实现"></a>2. 防抖节流函数的实现</h4><p>例子参考：<a href="/2021/04/03/2021/%E8%A7%A3%E6%9E%90%E5%87%A0%E4%B8%AAJS%E6%89%8B%E5%86%99%E5%87%BD%E6%95%B0%EF%BC%88call%E3%80%81%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81%EF%BC%89/">解析几个JS手写函数（call、防抖节流）</a></p><h2 id="this的5种场景"><a href="#this的5种场景" class="headerlink" title="this的5种场景"></a>this的5种场景</h2><h4 id="0-函数直接调用"><a href="#0-函数直接调用" class="headerlink" title="0. 函数直接调用"></a>0. 函数直接调用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myfunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">myfunc(); <span class="comment">// this是window, 严格模式下是undefined</span></span><br></pre></td></tr></table></figure><p>逗号表达式情况:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    show: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;this:&#x27;</span>, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">(<span class="number">0</span>, obj.show)(); <span class="comment">// window</span></span><br><span class="line"><span class="comment">// 等于 var re = function () &#123; console.lo... &#125; ; re();</span></span><br></pre></td></tr></table></figure><h4 id="1-函数被别人调用时"><a href="#1-函数被别人调用时" class="headerlink" title="1. 函数被别人调用时"></a>1. 函数被别人调用时</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myfunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    myfunc: myfunc</span><br><span class="line">&#125;;</span><br><span class="line">a.myfunc(); <span class="comment">// this是对象a</span></span><br></pre></td></tr></table></figure><p>看似调用的形式，实则直接调用的情况:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    test: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        run()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.test() <span class="comment">// 这里this是window</span></span><br></pre></td></tr></table></figure><p>谁调用this就是谁:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    sub: &#123;</span><br><span class="line">        show: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;this:&#x27;</span>, <span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.sub.show() <span class="comment">// this为对象sub</span></span><br></pre></td></tr></table></figure><h4 id="2-new创建实例时"><a href="#2-new创建实例时" class="headerlink" title="2. new创建实例时"></a>2. new创建实例时</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">&#x27;name&#x27;</span>); <span class="comment">// p</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    show: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;this:&#x27;</span>, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> newobj = <span class="keyword">new</span> obj.show(); <span class="comment">// newobj</span></span><br></pre></td></tr></table></figure><p>new &gt; bind &gt; 调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    show: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;\nthis:\n\n&#x27;</span>, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.show(); <span class="comment">// obj</span></span><br><span class="line">(obj.show.bind(obj))(); <span class="comment">// obj</span></span><br><span class="line"><span class="keyword">var</span> newobj = <span class="keyword">new</span> (obj.show.bind(obj))(); <span class="comment">// newobj</span></span><br></pre></td></tr></table></figure><h4 id="3-apply、call、bind时"><a href="#3-apply、call、bind时" class="headerlink" title="3. apply、call、bind时"></a>3. apply、call、bind时</h4><p>一般bind要优与call/apply。（call参数多，apply参数少）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getColor</span>(<span class="params">color</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.color = color;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">name, color</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name; <span class="comment">// this指的是实例car</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">    getColor.call(<span class="built_in">this</span>, color); <span class="comment">// 这里的this从原本的getColor，变成了car</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> car = <span class="keyword">new</span> Car(<span class="string">&#x27;卡⻋&#x27;</span>, <span class="string">&#x27;绿色&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id="4-箭头函数"><a href="#4-箭头函数" class="headerlink" title="4. 箭头函数"></a>4. 箭头函数</h4><p>没有自己的this，也不能被new关键字调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    myfunc: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    myfunc2: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">a.myfunc(); <span class="comment">// this是a</span></span><br><span class="line">a.myfunc2(); <span class="comment">// this是setTimeout</span></span><br></pre></td></tr></table></figure><h4 id="5-综合应用"><a href="#5-综合应用" class="headerlink" title="5. 综合应用"></a>5. 综合应用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    show: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;this:&#x27;</span>, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> elem = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;xxx&#x27;</span>);</span><br><span class="line">elem.addEventListener(<span class="string">&#x27;click&#x27;</span>, obj.show); <span class="comment">// 传递给了click事件，执行时相当于直接调用，this指window</span></span><br><span class="line">elem.addEventListener(<span class="string">&#x27;click&#x27;</span>, obj.show.bind(obj)); <span class="comment">// 显式绑定了obj，this指obj</span></span><br><span class="line">elem.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    obj.show(); <span class="comment">// 执行是调用出来的，this指obj</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i); <span class="comment">// 0 1 2 .... 9</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 时间循环，进入异步队列，调用时主栈for已执行完，i的值为10</span></span><br><span class="line">        <span class="built_in">console</span>.log(i); <span class="comment">// 10</span></span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123; <span class="comment">// 独立的10个作用域块了</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(i); <span class="comment">// 0 1 2 3 .... 9</span></span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i); <span class="comment">// 0 1 2 3 .... 9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被js变量提升影响:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showPerson</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(person); <span class="comment">// 如果没有var定义的person那么输出是1</span></span><br><span class="line">    <span class="keyword">var</span> person = <span class="number">2</span>; <span class="comment">// 变量提升：函数showPerson作用域内person被提前声明初始化并赋值undefind</span></span><br><span class="line">&#125;</span><br><span class="line">showPerson(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>被js函数提升影响:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showPerson</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(person);</span><br><span class="line">    <span class="keyword">var</span> person = <span class="number">2</span>; <span class="comment">// 在函数作用域内任何地方定义此person均不会影响结果</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params"></span>) </span>&#123; &#125; <span class="comment">// 函数提升：提前声明初始化并赋值整个函数内容</span></span><br><span class="line">&#125;</span><br><span class="line">showPerson(); <span class="comment">// function person() &#123; &#125;</span></span><br></pre></td></tr></table></figure><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name: <span class="number">2</span>,</span><br><span class="line">    show: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;name is:&#x27;</span>, <span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line">person.show(); <span class="comment">// name is: 1</span></span><br><span class="line">Person.prototype.show(); <span class="comment">// name is: 2</span></span><br><span class="line"></span><br><span class="line">Person.prototype.show = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;new show&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">person.show(); <span class="comment">// new show</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 前端巩固 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈浏览器Dom事件、Ajax、Bom</title>
      <link href="/2021/03/29/2021/%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA-%E6%B5%8F%E8%A7%88%E5%99%A8dom%E4%BA%8B%E4%BB%B6%E3%80%81Ajax%E3%80%81Bom/"/>
      <url>/2021/03/29/2021/%E5%89%8D%E7%AB%AF%E5%B7%A9%E5%9B%BA-%E6%B5%8F%E8%A7%88%E5%99%A8dom%E4%BA%8B%E4%BB%B6%E3%80%81Ajax%E3%80%81Bom/</url>
      
        <content type="html"><![CDATA[<h3 id="0-事件流以及事件委托机制"><a href="#0-事件流以及事件委托机制" class="headerlink" title="0. 事件流以及事件委托机制"></a>0. 事件流以及事件委托机制</h3><p><img src= "/img/loading__.gif" data-lazy-src="http://img.palxp.com/2020/12/1608640644635.png" alt="image.png"></p><p>假设一段DOM结构如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span> 1 <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span> 2 <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span> 3 <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>js中对body注册点击事件(也可以对ul注册点击事件)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;捕获阶段&#x27;</span>);</span><br><span class="line">&#125;, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;冒泡阶段&#x27;</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p>true表示捕获阶段触发，false表示冒泡阶段触发</p><p>如果我们为每个li赋予点击事件，会注册多个方法，但是在ul(外层父层)中只需要注册一次，利用捕获冒泡的原理，相当于每个li都能触发事件，这就是事件委托机制。</p><p>其中可通过e.target来判断和执行不同的点击结果。</p><h3 id="1-事件类型"><a href="#1-事件类型" class="headerlink" title="1. 事件类型"></a>1. 事件类型</h3><p>并不是所有事件都会冒泡。如注册scroll事件，就不会触发冒泡。</p><p>mouseover &amp; mouseenter 的区别就是后者不会冒泡，假设给ul设置了mouseover事件，在鼠标经过ul时理论应该触发一次事件，但是因为ul中还有li元素，鼠标每经过一个li元素就会冒泡到ul上的mouseover，造成多次触发，所以需要在li中多处理阻止冒泡，而mouseenter就不会出现这种问题。</p><h3 id="2-css对事件的影响"><a href="#2-css对事件的影响" class="headerlink" title="2. css对事件的影响"></a>2. css对事件的影响</h3><ol><li>我们经常会碰到类似设置半透明遮罩的需求，通常是绝对定位一个div盖在元素上方，这时遮罩div会覆盖住当前元素使得元素无法进行交互行为，通过一行css代码即可解决：<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attribute">pointer-events</span>: none; &#125;</span><br></pre></td></tr></table></figure></li><li>指定某个给定的区域是否允许用户操作，以及如何响应用户操作（比如浏览器自带的划动、缩放等）<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attribute">touch-action</span>: .... &#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-Ajax基本实现四步"><a href="#3-Ajax基本实现四步" class="headerlink" title="3. Ajax基本实现四步"></a>3. Ajax基本实现四步</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">majax</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line"></span><br><span class="line">    xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    xhr.open(<span class="string">&#x27;post&#x27;</span>, <span class="string">&#x27;/xxx&#x27;</span>, <span class="literal">true</span>)</span><br><span class="line">    xhr.setRequestHeader(<span class="string">&#x27;Content-type&#x27;</span>, <span class="string">&#x27;application/json;charset=UTF-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> params = &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    xhr.send(params)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-GET与POST的区别"><a href="#4-GET与POST的区别" class="headerlink" title="4. GET与POST的区别"></a>4. GET与POST的区别</h3><p>GET</p><ul><li>没有请求体，参数大小有限制</li><li>传参局限于URL编码</li><li>参数不变时，因为浏览器协调缓存原因，可能会出现304问题（解决方法请求url带随机参数）</li><li>常用于做数据拉取</li></ul><p>POST</p><ul><li>有请求体，需要设置content-type，参数大小无限制</li><li>支持多种编码格式</li><li>常用于做数据提交保存</li></ul><h3 id="5-常见问题"><a href="#5-常见问题" class="headerlink" title="5. 常见问题"></a>5. 常见问题</h3><p>什么是事件传播?</p><ul><li>事件发生时会在元素节点与根节点之间按照特定的顺序传播</li></ul><p>什么是事件冒泡？</p><ul><li>事件按照从最特定的事件目标到最不特定的事件目标(document对象)的顺序触发。</li></ul><p>什么是事件捕获？</p><ul><li>事件按照从最不特定的事件目标到最特定的事件目标(document对象)的顺序。</li></ul><p>stopPropagation() 和 stopImmediatePropagation() 之间有什么区别？</p><ul><li>均为阻止事件的冒泡或捕获。前者用于阻止事件传播，在事件传播的任何阶段都可以调用它。后者为阻止默认事件(如a标签submit表单等)。</li></ul><p>如何知道是否在元素中使用了event.preventDefault()方法？</p><ul><li>event.defaultpreventing 返回Boolean值来判断。</li></ul><p>Event对象中，target和currentTarget的区别？</p><ul><li>e.target 指向触发事件监听的对象，e.currentTarget 指向添加监听事件的对象。</li></ul><p>什么是跨域，工作中如何处理跨域问题</p><h4 id="什么情况下会自动发起options请求"><a href="#什么情况下会自动发起options请求" class="headerlink" title="什么情况下会自动发起options请求"></a>什么情况下会自动发起options请求</h4><p>使用了PUT/DELETE/CONNECT/OPTIONS/TRACE/PATCH任意一种请求类型，Content-type不属于下列之一 application/x-www-form-urlencoded、multipart/form-data、text/plain</p><p>跨域请求会携带cookie吗？如果想携带，需要怎么做</p><h4 id="常见的请求格式（content-type）有哪些"><a href="#常见的请求格式（content-type）有哪些" class="headerlink" title="常见的请求格式（content-type）有哪些"></a>常见的请求格式（content-type）有哪些</h4><p><a href="https://zhuanlan.zhihu.com/p/127800327">几种常见的Content-Type类型</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 前端巩固 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>那些奇怪怪的JavaScript</title>
      <link href="/2020/12/04/2020/%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84JavaScript/"/>
      <url>/2020/12/04/2020/%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84JavaScript/</url>
      
        <content type="html"><![CDATA[<h4 id="JS浮点数丢失精度问题"><a href="#JS浮点数丢失精度问题" class="headerlink" title="JS浮点数丢失精度问题"></a>JS浮点数丢失精度问题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.3 - 0.2 !&#x3D;&#x3D; 0.1  &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><h4 id="JS最大数字长度"><a href="#JS最大数字长度" class="headerlink" title="JS最大数字长度"></a>JS最大数字长度</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Number x &#x3D; 9007199254740992 &#x2F;&#x2F; 即2的53次方，js数字长度最大不能超过这个数值</span><br></pre></td></tr></table></figure><h4 id="parseInt-太小的数字会产生-bug"><a href="#parseInt-太小的数字会产生-bug" class="headerlink" title="parseInt 太小的数字会产生 bug"></a>parseInt 太小的数字会产生 bug</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parseInt(0.00000000233) &#x2F;&#x2F; 2</span><br><span class="line">parseInt(0.00000000456) &#x2F;&#x2F; 4</span><br></pre></td></tr></table></figure><h4 id="NaN更像是一个范围，在JS中比较特殊，它并不会等于自身"><a href="#NaN更像是一个范围，在JS中比较特殊，它并不会等于自身" class="headerlink" title="NaN更像是一个范围，在JS中比较特殊，它并不会等于自身"></a>NaN更像是一个范围，在JS中比较特殊，它并不会等于自身</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const x &#x3D; NaN;</span><br><span class="line">x !&#x3D;&#x3D; x  &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><h4 id="isNaN也存在bug，ES6中对其进行了修复"><a href="#isNaN也存在bug，ES6中对其进行了修复" class="headerlink" title="isNaN也存在bug，ES6中对其进行了修复"></a>isNaN也存在bug，ES6中对其进行了修复</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">isNaN(&#39;abc&#39;);       &#x2F;&#x2F; true</span><br><span class="line">Number.isNaN(&#39;abc&#39;) &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure><h4 id="null的设计问题"><a href="#null的设计问题" class="headerlink" title="null的设计问题"></a>null的设计问题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1 + null          &#x2F;&#x2F; 1</span><br><span class="line">1 + undefined     &#x2F;&#x2F; NaN</span><br><span class="line"></span><br><span class="line">Number(null)      &#x2F;&#x2F; 0</span><br><span class="line">Number(undefined) &#x2F;&#x2F; NaN</span><br><span class="line"></span><br><span class="line">typeof null &#x3D;&#x3D;&#x3D; &#39;object&#39;  &#x2F;&#x2F; true</span><br><span class="line">null instanceof Object    &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; null等于object类型，但却不是继承于object</span><br></pre></td></tr></table></figure><h4 id="到底鸡生蛋还是蛋生鸡"><a href="#到底鸡生蛋还是蛋生鸡" class="headerlink" title="到底鸡生蛋还是蛋生鸡"></a>到底鸡生蛋还是蛋生鸡</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 反正挺生草</span><br><span class="line">Object instanceof Function &#x2F;&#x2F; true</span><br><span class="line">Function instanceof Object &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jenkins自动化前后端项目部署记录以及一些坑</title>
      <link href="/2020/11/29/2020/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E5%89%8D%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"/>
      <url>/2020/11/29/2020/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E5%89%8D%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Jenkins依赖Java环境，默认服务器已经安装好Jdk与Tomcat</p></blockquote><h3 id="0-开始安装"><a href="#0-开始安装" class="headerlink" title="0. 开始安装"></a>0. 开始安装</h3><p><a href="http://mirrors.jenkins.io/war-stable/2.235.3/jenkins.war">下载war包</a>，启动Tomcat安装，此时Jenkins已经运行，打开网页后按照提示在服务器对应文件中找到密码，输入并进入新手安装，选择默认的安装，这时别管它，应该会出现一系列失败，先进入tomcat刚安装的对应目录中：<br><img src= "/img/loading__.gif" data-lazy-src="http://img.palxp.com/2020/11/1606645892192.png" alt="截屏20201129 下午6.31.07.png"><br>找到路径 <code>\WEB-INF\detached-plugins</code> 文件夹下确认是否存在 <code>cloudbees-folder.hpi</code> 这个文件，如果缺少则<a href="http://ftp.icm.edu.pl/packages/jenkins/plugins/cloudbees-folder/">这里手动下载</a>后放进去。</p><p>进入工作目录（不是安装目录，一般是root文件夹下的.jenkins文件夹），找到<code>hudson.model.UpdateCenter.xml</code>这个文件，将URL改为<code>https://updates.jenkins-zh.cn/update-center.json</code></p><p>工作目录下updates文件夹<code>default.json</code>文件中，将所有 <code>http://updates.jenkins-ci.org/download/</code> 替换为 <code>https://updates.jenkins-zh.cn/</code></p><p>进行完以上所有步骤，重启Jenkins，等待安装完成。</p><h3 id="1-创建用户"><a href="#1-创建用户" class="headerlink" title="1. 创建用户"></a>1. 创建用户</h3><p>首先配置下git，进入Manager -&gt; Global Tool Config… 找到 Git 位置 Path to Git executable 填入路径 ：<code>/usr/local/git/bin/git</code><br><img src= "/img/loading__.gif" data-lazy-src="http://img.palxp.com/2020/11/1606646395030.png" alt="截屏20201129 下午6.39.27.png"></p><p>开启Webhook链接：进入Manager -&gt; Configure System，找到GitHub  -&gt; 高级 -&gt; 勾选Hook URL打开，复制下payload Url<br>通常是  <code>http://你的域名/jenkins/github-webhook/</code></p><blockquote><p>进入<a href="https://github.com/">GitHub</a>，点击setting，进入setting页面点击左下角的Developer settings，点击跳转到Personal access tokens，创建token，勾选 repo 和 admin:repo_hook;</p></blockquote><p>进入Jenkins configure配置githubserver，(Credentials)Add选择“secret text”—Secret输入token，勾选管理hook</p><blockquote><p>Yum配置国内源（已配置略过）<br><a href="https://www.jianshu.com/p/45f2addf30de">https://www.jianshu.com/p/45f2addf30de</a></p></blockquote><h3 id="2-Git相关"><a href="#2-Git相关" class="headerlink" title="2. Git相关"></a>2. Git相关</h3><p>下载GIt<br><a href="https://mirrors.edge.kernel.org/pub/software/scm/git/">https://mirrors.edge.kernel.org/pub/software/scm/git/</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br><span class="line">yum remove -y git</span><br><span class="line">yum -y install libcurl-devel expat-devel curl-devel  gettext-devel openssl-devel zlib-devel</span><br><span class="line">yum -y install  gcc perl-ExtUtils-MakeMaker</span><br><span class="line">cd &#x2F;usr&#x2F;local&#x2F;src&#x2F;</span><br><span class="line">wget https:&#x2F;&#x2F;mirrors.edge.kernel.org&#x2F;pub&#x2F;software&#x2F;scm&#x2F;git&#x2F;git-2.1.1.tar.gz</span><br><span class="line">tar -zvxf git-2.1.1.tar.gz</span><br><span class="line">cd git-2.1.1</span><br><span class="line">make prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;git all</span><br><span class="line">make prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;git install</span><br></pre></td></tr></table></figure><p>添加git到环境变量(可能需要)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;export PATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;git&#x2F;bin&quot; &gt;&gt; &#x2F;etc&#x2F;bashrc</span><br><span class="line">source &#x2F;etc&#x2F;bashrc</span><br></pre></td></tr></table></figure><p>注意在Github的相关项目下 Settings Webhooks 配置push时payload。</p><h3 id="3-通常的配置实例"><a href="#3-通常的配置实例" class="headerlink" title="3. 通常的配置实例"></a>3. 通常的配置实例</h3><p><img src= "/img/loading__.gif" data-lazy-src="http://img.palxp.com/2020/11/1606648598430.png" alt="截屏20201129 下午7.13.44.png"><img src= "/img/loading__.gif" data-lazy-src="http://img.palxp.com/2020/11/1606648598469.png" alt="截屏20201129 下午7.14.24.png"><img src= "/img/loading__.gif" data-lazy-src="http://img.palxp.com/2020/11/1606648598521.png" alt="截屏20201129 下午7.14.47.png"></p><p>备注：这里一般不勾选“构建环境”中的Delete workplace….会增加构建时间。</p><h3 id="4-常用构建shell记录"><a href="#4-常用构建shell记录" class="headerlink" title="4. 常用构建shell记录"></a>4. 常用构建shell记录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rm -rf &#x2F;home&#x2F;shawn&#x2F;某工程项目目录&#x2F;* # 每次部署先清空，适合较小项目</span><br><span class="line">mv -f .&#x2F;* &#x2F;home&#x2F;shawn&#x2F;某工程项目目录 # 转移部署文件到指定目录</span><br><span class="line">chmod -R 775 &#x2F;home&#x2F;shawn&#x2F;某工程项目目录 # 设置权限防止nginx403</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>与UI对线的前端技巧之Gradient剪卡风格</title>
      <link href="/2020/11/29/2020/%E4%B8%8EUI%E8%AE%BE%E8%AE%A1%E5%B8%88%E5%AF%B9%E7%BA%BF%E7%9A%84%E5%89%8D%E7%AB%AF%E6%8A%80%E5%B7%A7%EF%BC%8CGradient%E5%89%AA%E5%8D%A1%E9%A3%8E%E6%A0%BC/"/>
      <url>/2020/11/29/2020/%E4%B8%8EUI%E8%AE%BE%E8%AE%A1%E5%B8%88%E5%AF%B9%E7%BA%BF%E7%9A%84%E5%89%8D%E7%AB%AF%E6%8A%80%E5%B7%A7%EF%BC%8CGradient%E5%89%AA%E5%8D%A1%E9%A3%8E%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<h3 id="0-css实现剪卡风格内倒角"><a href="#0-css实现剪卡风格内倒角" class="headerlink" title="0. css实现剪卡风格内倒角"></a>0. css实现剪卡风格内倒角</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.card &#123;</span><br><span class="line">    width: <span class="number">200</span>px;</span><br><span class="line">    height: <span class="number">100</span>px;</span><br><span class="line">    position: relative;</span><br><span class="line">    background-image: </span><br><span class="line">        radial-gradient(circle at left 50px, #fff, #fff 10px, transparent 10px),</span><br><span class="line">        radial-gradient(circle at right 50px, #fff, #fff 10px, transparent 11px),</span><br><span class="line">        radial-gradient(circle at 100px top, #fff, #fff 10px, transparent 11px),</span><br><span class="line">        radial-gradient(circle at 100px bottom, #fff, #fff 10px, transparent 11px);</span><br><span class="line">    background-color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading__.gif" data-lazy-src="http://img.palxp.com/2020/11/1606644246003.png" alt="内倒角效果图"></p><h3 id="1-实现波浪框"><a href="#1-实现波浪框" class="headerlink" title="1. 实现波浪框"></a>1. 实现波浪框</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.card:after &#123;</span><br><span class="line">    content: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: <span class="number">0</span>px;</span><br><span class="line">    bottom: <span class="number">0</span>px;</span><br><span class="line">    left: <span class="number">-5</span>px;</span><br><span class="line">    width: <span class="number">10</span>px;</span><br><span class="line">    height: <span class="number">100</span>%;</span><br><span class="line">    background: radial-gradient(circle, black, black <span class="number">4</span>px, transparent <span class="number">5</span>px);</span><br><span class="line">    background-size: <span class="number">10</span>px <span class="number">10</span>px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading__.gif" data-lazy-src="http://img.palxp.com/2020/11/1606644470195.png" alt="波浪"></p><h3 id="2-css实现虚线"><a href="#2-css实现虚线" class="headerlink" title="2. css实现虚线"></a>2. css实现虚线</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.line &#123;</span><br><span class="line">    width: 100%;</span><br><span class="line">    height: 1px;</span><br><span class="line">    background-image: linear-gradient(to right, #ccc 0%, #ccc 50%, transparent 50%);</span><br><span class="line">    background-size: 12px 1px;</span><br><span class="line">    background-repeat: repeat-x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading__.gif" data-lazy-src="http://img.palxp.com/2020/11/1606644572902.png" alt="虚线"></p><p>改变宽度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background-size: 20px 1px;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading__.gif" data-lazy-src="http://img.palxp.com/2020/11/1606644634179.png" alt="虚线2"></p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>总会用到前端姿势-CSS篇</title>
      <link href="/2020/11/29/2020/%E6%80%BB%E4%BC%9A%E7%94%A8%E5%88%B0%E7%9A%84%E5%89%8D%E7%AB%AF%E5%B0%8F%E5%A7%BF%E5%8A%BF%E2%80%94%E2%80%94CSS%E7%AF%87.md/"/>
      <url>/2020/11/29/2020/%E6%80%BB%E4%BC%9A%E7%94%A8%E5%88%B0%E7%9A%84%E5%89%8D%E7%AB%AF%E5%B0%8F%E5%A7%BF%E5%8A%BF%E2%80%94%E2%80%94CSS%E7%AF%87.md/</url>
      
        <content type="html"><![CDATA[<h3 id="0-文本自动换行bug"><a href="#0-文本自动换行bug" class="headerlink" title="0. 文本自动换行bug"></a>0. 文本自动换行bug</h3><p>假设一个宽度固定的div内有一段文字，那么浏览器默认处理方式会比较傻，纯中文下乍一看没问题，但英文与数字混搭等情况容易出现bug，此时解决方法有两种css方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">word-wrap: <span class="keyword">break</span>-word; <span class="comment">// 对过长单词会先另起一行</span></span><br><span class="line">word-<span class="keyword">break</span>: <span class="keyword">break</span>-all; <span class="comment">// 粗暴地拆掉单词并换行，比较常用</span></span><br></pre></td></tr></table></figure><h3 id="1-css实现iPhone系列黑边适配"><a href="#1-css实现iPhone系列黑边适配" class="headerlink" title="1. css实现iPhone系列黑边适配"></a>1. css实现iPhone系列黑边适配</h3><p>以往的iPhone X 适配比较简单粗暴，通常是正则判断机型来做出相应处理，如今需要适配的iPhone机型早已不止X系列，好在css有对应的处理方案，非常实用，那就是 viweport-fit 属性：</p><p>需要设置页面内容完全覆盖整个窗口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, viewport-fit&#x3D;cover&quot;&gt;</span><br></pre></td></tr></table></figure><p>只有设置了 viewport-fit=cover，env()才生效，根据情况来使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">padding-bottom: constant(safe-area-inset-bottom);</span><br><span class="line">padding-bottom: env(safe-area-inset-bottom);</span><br></pre></td></tr></table></figure><p>也可以使用计算属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">calc(55px +  constant(safe-area-inset-bottom))</span><br></pre></td></tr></table></figure><h3 id="2-文本超出省略"><a href="#2-文本超出省略" class="headerlink" title="2. 文本超出省略"></a>2. 文本超出省略</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">display: -webkit-box;</span><br><span class="line">-webkit-box-orient: vertical;</span><br><span class="line">-webkit-line-clamp: 3; &#x2F;** 最大行数 **&#x2F;</span><br><span class="line">overflow: hidden;</span><br></pre></td></tr></table></figure><h3 id="4-ios滑动不流畅"><a href="#4-ios滑动不流畅" class="headerlink" title="4. ios滑动不流畅"></a>4. ios滑动不流畅</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">overflow: auto;</span><br><span class="line">-webkit-overflow-scrolling: touch;</span><br></pre></td></tr></table></figure><h3 id="5-隐藏div滚动条"><a href="#5-隐藏div滚动条" class="headerlink" title="5. 隐藏div滚动条"></a>5. 隐藏div滚动条</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div::-webkit-scrollbar &#123;</span><br><span class="line">    display: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-ios-audio-无法自动播放、循环播放的问题"><a href="#6-ios-audio-无法自动播放、循环播放的问题" class="headerlink" title="6. ios audio 无法自动播放、循环播放的问题"></a>6. ios audio 无法自动播放、循环播放的问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var music &#x3D; document.getElementById(&#39;video&#39;);</span><br><span class="line">var state &#x3D; 0;</span><br><span class="line"></span><br><span class="line">document.addEventListener(&#39;touchstart&#39;, function()&#123;</span><br><span class="line">    if(state&#x3D;&#x3D;0)&#123;</span><br><span class="line">        music.play();</span><br><span class="line">        state&#x3D;1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, false);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 微信浏览器</span><br><span class="line">document.addEventListener(&quot;WeixinJSBridgeReady&quot;, function () &#123;</span><br><span class="line">    music.play();</span><br><span class="line">&#125;, false);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;循环播放</span><br><span class="line">music.onended &#x3D; function () &#123;</span><br><span class="line">    music.load();</span><br><span class="line">    music.play();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-水平垂直居中"><a href="#7-水平垂直居中" class="headerlink" title="7. 水平垂直居中"></a>7. 水平垂直居中</h3><p>绝对定位，需要声明宽高</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 0;</span><br><span class="line">    right: 0;</span><br><span class="line">    bottom: 0;</span><br><span class="line">    left: 0;</span><br><span class="line">    margin: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>flex，父级控制，比较常用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.parent &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content: center;</span><br><span class="line">    align-items: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>grid，父级控制，更简洁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.parent &#123;</span><br><span class="line">    display: grid;</span><br><span class="line">    place-items: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-div可编辑"><a href="#8-div可编辑" class="headerlink" title="8. div可编辑"></a>8. div可编辑</h3><p>富文本编辑器原理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div contenteditable&#x3D;&quot;true&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><h3 id="9-cslc"><a href="#9-cslc" class="headerlink" title="9. cslc"></a>9. cslc</h3><p>项目中常用css预编译，css计算表达式一般很少用到，且可能存在性能问题。但是需要的时候使用还是挺方便的，比如上面iphone黑条的适配。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">    width: calc(10rem - 20px + 5%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的宿舍桌面版本迭代历史</title>
      <link href="/2020/08/29/2020/%E6%88%91%E7%9A%84%E5%AE%BF%E8%88%8D%E6%A1%8C%E9%9D%A2%E7%89%88%E6%9C%AC%E8%BF%AD%E4%BB%A3%E5%8E%86%E5%8F%B2/"/>
      <url>/2020/08/29/2020/%E6%88%91%E7%9A%84%E5%AE%BF%E8%88%8D%E6%A1%8C%E9%9D%A2%E7%89%88%E6%9C%AC%E8%BF%AD%E4%BB%A3%E5%8E%86%E5%8F%B2/</url>
      
        <content type="html"><![CDATA[<p>这篇文章就稍微记录一下近两年来桌面的一些变化吧</p><p><img src= "/img/loading__.gif" data-lazy-src="http://img.palxp.com/2020/08/1598693234021.jpeg" alt="1523085236000.jpeg"></p><p>最初经过一系列不重要迭代后的1.0版本，藏在屏幕后的ps4是我每天下班后的最大消遣，核心是利用分线器控制屏幕的切换，当时买的小分线器还有个遥控，不过很少用到。</p><p><img src= "/img/loading__.gif" data-lazy-src="http://img.palxp.com/2020/08/1598693550957.jpeg" alt="1529922070000.jpeg"></p><p>后面往桌子旁加了两张几十块的小桌子，作用基本只是用来放笔记本电脑，因为没有买椅子，只是淘宝随便买了个休闲沙发椅，不适合办公学习，基本上坐上去就想打游戏 (⊙ˍ⊙)，桌面离得也有点远，双手要抬起来久了会酸，所以操作区域基本是键盘抽屉那里，键盘和手绘板的位置实际会一直切换，加了个键盘托夹在键盘抽屉那稍微解放右手，此时整体规模已经定型🤨</p><p><img src= "/img/loading__.gif" data-lazy-src="http://img.palxp.com/2020/08/1598694179415.jpeg" alt="1542733011000.jpeg"></p><p>当时的键盘换了一些键帽🤠，这个是国产机械键盘樱桃茶轴，黑轴青轴都敲过，现在只用红轴了，很多事情兜兜转转最后会发现平淡才是真。</p><p><img src= "/img/loading__.gif" data-lazy-src="http://img.palxp.com/2020/08/1598694935248.jpeg" alt="1543235297000.jpeg"></p><p>后面换了台明基的显示器，当时冲着支持hdr买的，但事实证明两千块以下的显示器感受起来都差不多，hdr效果也是跟更大尺寸的更大流明度有关，玩具车。</p><table><thead><tr><th><img src= "/img/loading__.gif" data-lazy-src="http://img.palxp.com/2020/08/1598697190306.jpeg?imageMogr2/auto-orient" alt="1543219472000.jpeg"></th><th><img src= "/img/loading__.gif" data-lazy-src="http://img.palxp.com/2020/08/1598695131920.jpeg?imageMogr2/auto-orient" alt="1543235283000.jpeg"></th></tr></thead></table><p>于是之前的显示器竖着放到地上，铺上地毯直接盘腿坐地上打打码 ﾍ(ﾟ∀ﾟﾍ)</p><p>—- 搬了一波宿舍 —-</p><table><thead><tr><th><img src= "/img/loading__.gif" data-lazy-src="http://img.palxp.com/2020/08/1598695309334.jpeg" alt="1555871002000.jpeg"></th><th><img src= "/img/loading__.gif" data-lazy-src="http://img.palxp.com/2020/08/1598695802662.jpeg" alt="1558750067000.jpeg"></th></tr></thead></table><p>搬了宿舍房间空空如也，直接买了张1米6长的桌子，这是个大版本更新，增加了一台PC主机，这也意味着一台显示器需要同时被ps4、笔记本、PC主机共用，为了桌面整洁用磁铁胶带魔术贴啥的把线全理到桌面下，部分外设也都逐渐无线化，正式进入2.0时代🤗。</p><p><img src= "/img/loading__.gif" data-lazy-src="http://img.palxp.com/2020/08/1598695949047.jpeg" alt="1575196541000.jpeg"></p><p>桌面逐渐被我填满，所以支架是个不错的东西</p><p><img src= "/img/loading__.gif" data-lazy-src="http://img.palxp.com/2020/08/1598685917000.jpeg"></p><p>2020.08 现在的桌面，朴实无华</p><p>—- 与蚂蚁疯狂斗争，大扫除一番之后 —-</p><table><thead><tr><th><img src= "/img/loading__.gif" data-lazy-src="http://img.palxp.com/2020/11/1606636996436.jpeg?imageMogr2/auto-orient" alt="1543219472000.jpeg"></th><th><img src= "/img/loading__.gif" data-lazy-src="http://img.palxp.com/2020/11/1606637018451.jpeg?imageMogr2/auto-orient" alt="1543235283000.jpeg"></th><th><img src= "/img/loading__.gif" data-lazy-src="http://img.palxp.com/2020/11/1606637024946.jpeg?imageMogr2/auto-orient" alt="1543235283000.jpeg"></th></tr></thead></table><p><img src= "/img/loading__.gif" data-lazy-src="http://img.palxp.com/2020/11/1606637178414.jpeg" alt="下载 2.jpeg"></p><p>2020.11 现在的桌面，更加追求简洁，重构集线，方便打扫</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于vue2的12种组件通讯方式</title>
      <link href="/2020/05/09/2020/%E5%85%B3%E4%BA%8Evue2%E7%9A%8412%E7%A7%8D%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF%E6%96%B9%E5%BC%8F/"/>
      <url>/2020/05/09/2020/%E5%85%B3%E4%BA%8Evue2%E7%9A%8412%E7%A7%8D%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>此文索引记录，完整文章 &gt; <a href="/2021/04/13/vue2%E9%80%9A%E4%BF%A1/">前往查看</a></p><h5 id="1-props"><a href="#1-props" class="headerlink" title="1. props"></a>1. props</h5><a id="more"></a><h5 id="2-emit-父传子"><a href="#2-emit-父传子" class="headerlink" title="2. $emit 父传子"></a>2. $emit 父传子</h5><h5 id="3-vuex"><a href="#3-vuex" class="headerlink" title="3. vuex"></a>3. vuex</h5><h5 id="4-attrs"><a href="#4-attrs" class="headerlink" title="4. $attrs"></a>4. $attrs</h5><h5 id="5-listeners"><a href="#5-listeners" class="headerlink" title="5. $listeners"></a>5. $listeners</h5><h5 id="6-provide-inject"><a href="#6-provide-inject" class="headerlink" title="6. provide inject"></a>6. provide inject</h5><h5 id="7-parent-children"><a href="#7-parent-children" class="headerlink" title="7. $parent $children"></a>7. $parent $children</h5><h5 id="8-refs"><a href="#8-refs" class="headerlink" title="8.$refs"></a>8.$refs</h5><h5 id="9-sync修饰符"><a href="#9-sync修饰符" class="headerlink" title="9. .sync修饰符"></a>9. .sync修饰符</h5><h5 id="10-v-slot插槽"><a href="#10-v-slot插槽" class="headerlink" title="10. v-slot插槽"></a>10. v-slot插槽</h5><h5 id="11-Event-Bus"><a href="#11-Event-Bus" class="headerlink" title="11. Event Bus"></a>11. Event Bus</h5><h5 id="12-路由传参"><a href="#12-路由传参" class="headerlink" title="12. 路由传参"></a>12. 路由传参</h5>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>React学习笔记</title>
      <link href="/2020/04/01/2020/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/04/01/2020/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="主要API"><a href="#主要API" class="headerlink" title="主要API"></a>主要API</h1><h2 id="React-createElement"><a href="#React-createElement" class="headerlink" title="React.createElement"></a>React.createElement</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">React.createElement(</span><br><span class="line">  type, <span class="comment">// 必填，元素类型，可以是html 标签字符串 / React 组件</span></span><br><span class="line">  [props], <span class="comment">// 可选，元素属性，以对象形式展现</span></span><br><span class="line">  [...children] <span class="comment">// 可选，嵌套在元素内的子元素</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><a id="more"></a><p>eg：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rElmLi1 = React.createElement(<span class="string">&#x27;li&#x27;</span>, &#123;<span class="attr">id</span>:<span class="string">&#x27;li1&#x27;</span>&#125;, <span class="string">&#x27;one&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> rElmLi2 = React.createElement(<span class="string">&#x27;li&#x27;</span>, &#123;<span class="attr">id</span>:<span class="string">&#x27;li2&#x27;</span>&#125;, <span class="string">&#x27;two&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> rElmLi3 = React.createElement(<span class="string">&#x27;li&#x27;</span>, &#123;<span class="attr">id</span>:<span class="string">&#x27;li3&#x27;</span>&#125;, <span class="string">&#x27;three&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reactElementUl = React.createElement(<span class="string">&#x27;ul&#x27;</span>, &#123;<span class="attr">className</span>:<span class="string">&#x27;myList&#x27;</span>&#125;, rElmLi1,rElmLi2,rElmLi3);</span><br></pre></td></tr></table></figure><h2 id="ReactDOM-render"><a href="#ReactDOM-render" class="headerlink" title="ReactDOM.render"></a>ReactDOM.render</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(element, container, [callback])</span><br></pre></td></tr></table></figure><p>eg: </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">element</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> reactElementUl = React.createElement(...);</span><br><span class="line">    <span class="keyword">return</span> reactElementUl;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(element(), <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>);</span><br></pre></td></tr></table></figure><h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><ol><li>{ }表达式括号里推荐注释:/**/</li><li>使用className代替class，Label标签for属性使用HtmlFor，否则报错</li><li>组件名首字母必须是大写</li><li>行内样式双花括号，jsx驼峰写法不能有“-”：如<code>&lt;p style=&#123;&#123; fontSize:'15px ',zIndex: 3 &#125;&#125;&gt;</code></li><li>循环的key属性不能改动</li></ol><h1 id="单向数据流中的数据双向绑定"><a href="#单向数据流中的数据双向绑定" class="headerlink" title="单向数据流中的数据双向绑定"></a>单向数据流中的数据双向绑定</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&#x27;text&#x27;</span> value=&#123; <span class="built_in">this</span>.state.msg &#125; onChange=&#123; <span class="function">(<span class="params">e</span>) =&gt;</span> <span class="built_in">this</span>.txtChange(e) &#125;/&gt;</span><br><span class="line">txtChange = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">let</span> newVal = e.target.value</span><br><span class="line">   <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      msg: newVal</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">constructor(props)&#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state &#x3D; &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 组件即将被挂载</span><br><span class="line">componentWillMount()&#123; &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 页面渲染</span><br><span class="line">render() &#123;</span><br><span class="line">        return ( ...&lt;div&gt;... )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 组件加载完成</span><br><span class="line">componentDidMount()&#123; &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 即将被修改阶段</span><br><span class="line">componentWillUpdate()&#123; &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 更新完阶段 </span><br><span class="line">componentDidUpdate()&#123; &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 卸载前</span><br><span class="line">componentWillUnmount()&#123; &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 错误处理</span><br><span class="line">componentDidCatch()&#123; &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux安装Nginx过程小记</title>
      <link href="/2019/09/30/old/linux%E5%AE%89%E8%A3%85Nginx%E8%BF%87%E7%A8%8B%E5%B0%8F%E8%AE%B0/"/>
      <url>/2019/09/30/old/linux%E5%AE%89%E8%A3%85Nginx%E8%BF%87%E7%A8%8B%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>nginx安装过程记录</p><a id="more"></a><p>必须库安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install make zlib zlib-devel gcc-c++ libtool  openssl openssl-devel</span><br></pre></td></tr></table></figure><p>查看是否重复</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep pcre</span><br></pre></td></tr></table></figure><p>删除包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">yum remove&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line">PCRE安装</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;linux</span><br><span class="line">sudo -i</span><br><span class="line">cd &#x2F;usr&#x2F;local&#x2F;src&#x2F;</span><br><span class="line">wget http:&#x2F;&#x2F;downloads.sourceforge.net&#x2F;project&#x2F;pcre&#x2F;pcre&#x2F;8.35&#x2F;pcre-8.35.tar.gz</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf pcre-8.35.tar.gz</span><br><span class="line">cd pcre-8.35</span><br><span class="line">.&#x2F;configure</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>安装Nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo -i</span><br><span class="line">cd &#x2F;usr&#x2F;local&#x2F;src&#x2F;</span><br><span class="line">wget http:&#x2F;&#x2F;nginx.org&#x2F;download&#x2F;nginx-1.6.2.tar.gz</span><br><span class="line">tar zxvf nginx-1.6.2.tar.gz</span><br><span class="line">cd nginx-1.6.2</span><br><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;webserver&#x2F;nginx --with-http_stub_status_module --with-http_ssl_module --with-pcre&#x3D;&#x2F;usr&#x2F;local&#x2F;src&#x2F;pcre-8.35</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;init.d&#x2F;nginx</span><br><span class="line">nginx&#x3D;“&#x2F;usr&#x2F;local&#x2F;webserver&#x2F;nginx&#x2F;sbin&#x2F;nginx”</span><br><span class="line">NGINX_CONF_FILE&#x3D;“&#x2F;usr&#x2F;local&#x2F;webserver&#x2F;nginx&#x2F;conf&#x2F;nginx.conf”</span><br></pre></td></tr></table></figure><pre><code class="linux">chmod a+x /etc/init.d/nginx```启动```linux/usr/local/webserver/nginx/sbin/nginx```停止```linux/usr/local/webserver/nginx/sbin/nginx -s stop```</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux安装mysql过程小记</title>
      <link href="/2019/09/29/old/linux%E5%AE%89%E8%A3%85mysql%E8%BF%87%E7%A8%8B%E5%B0%8F%E8%AE%B0/"/>
      <url>/2019/09/29/old/linux%E5%AE%89%E8%A3%85mysql%E8%BF%87%E7%A8%8B%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>安装基本参照<a href="https://www.linuxidc.com/Linux/2017-12/149614.htm">这篇文章</a>，网上很多方法，有些需要的操作挺繁杂，这是我找到比较简单的方法，主要使用yum安装，但是第一次安装到一半卡住了，原因是rpm包的问题，将其换成：<br><code>wget http://repo.mysql.com/mysql57-community-release-el7-8.noarch.rpm</code><br>不行就再找找不同的源下载尝试。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue项目线上部署常见问题，以及Nginx反向代理</title>
      <link href="/2019/09/29/old/vue%E9%A1%B9%E7%9B%AE%E7%BA%BF%E4%B8%8A%E9%83%A8%E7%BD%B2%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%EF%BC%8C%E4%BB%A5%E5%8F%8ANginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
      <url>/2019/09/29/old/vue%E9%A1%B9%E7%9B%AE%E7%BA%BF%E4%B8%8A%E9%83%A8%E7%BD%B2%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%EF%BC%8C%E4%BB%A5%E5%8F%8ANginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>之所以说是”常见问题”，是因为我自己遇到了两次，做下记录= =</p><h4 id="出现空白页，路由刷新404的问题"><a href="#出现空白页，路由刷新404的问题" class="headerlink" title="出现空白页，路由刷新404的问题"></a>出现空白页，路由刷新404的问题</h4><a id="more"></a><p>解决办法一般为vue.config.js配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isProduction = process.env.NODE_ENV === <span class="string">&#x27;production&#x27;</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  publicPath: isProduction ? <span class="string">&#x27;./&#x27;</span> : <span class="string">&#x27;/&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刷新404是服务端配置问题，这里是Nginx的配置：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    root   /home/xxx/xxx; # web项目地址</span><br><span class="line">    index  index.html index.htm;</span><br><span class="line">    try_files $uri $uri/ /index.html;  # 这个配置是关键</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Nginx反向代理"><a href="#Nginx反向代理" class="headerlink" title="Nginx反向代理"></a>Nginx反向代理</h4><p>需求场景：我只有一个服务器和一个玉米，使用tomcat运行着这个博客程序(blog.palxp.com)，现在我需要在这台服务器上再发布一个前端程序和服务端程序，这时候就需要用到Nginx反向代理。</p><p>最终我在这台服务器上有两个程序：blog.xxx.com 和 app.xxx.com ，而后端由于只提供api所以直接发布到一个没到的端口上 app.xxx.com:9999</p><p>首先域名DNS解析：app和blog两个主机记录到主机ip，blog还是放在我之前的tomcat服务器跑，只是端口被我改成了8080，接着就是Nginx的配置：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  app.palxp.com;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root   /home/shawn/FrogPunch;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">        try_files $uri $uri/ /index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  blog.palxp.com;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://app.palxp.com:8080;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样访问app.palxp.com就是我发布的程序，而blog.palxp.com则被转发到8080端口</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue项目前端性能优化总结</title>
      <link href="/2019/09/29/old/vue%E9%A1%B9%E7%9B%AE%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/"/>
      <url>/2019/09/29/old/vue%E9%A1%B9%E7%9B%AE%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>三个层面：网络请求，JS优化，CSS优化</p><ul><li>减少http请求</li><li>图片懒加载</li><li>使用字体图标或svg，尽量不使用png，png尽量使用css图片精灵</li><li>避免使用闭包，减少DOM回流重绘，避免使用css表达式</li><li>不使用cookie，不使用iframe，不使用flash</li><li>尽量减少引用大量第三方库 (减少资源大小)</li><li>使用webpack插件压缩混淆去注释 (减少资源大小)</li><li>开启Gzip压缩 (减少请求资源大小)</li><li>vue可以使用路由懒加载 (避免一次性加载资源过多)</li></ul><a id="more"></a><h4 id="0-路由懒加载"><a href="#0-路由懒加载" class="headerlink" title="0. 路由懒加载"></a>0. 路由懒加载</h4><p>路由组件不使用直接引入，而是匿名函数返回形式，如下注释可以定义编译后的js文件名，在未进入该路由时此js文件的内容将不会被请求到：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">    component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &#x27;base&#x27; */</span> <span class="string">&#x27;@/views/Index.vue&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-开启gzip压缩"><a href="#1-开启gzip压缩" class="headerlink" title="1. 开启gzip压缩"></a>1. 开启gzip压缩</h4><p>1.1. 需要服务端做配置开启gzip功能，例如我的是nginx.conf配置：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gzip on;</span><br><span class="line">gzip_min_length 80k;</span><br><span class="line">gzip_buffers 4 16k;</span><br><span class="line">gzip_comp_level 5;</span><br><span class="line">gzip_types text/plain application/javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;</span><br></pre></td></tr></table></figure><p>1.2. vue.config.js配置编译gzip，npm安装相关插件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CompressionWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;compression-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  configureWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      config.plugins.push(</span><br><span class="line">        <span class="keyword">new</span> CompressionWebpackPlugin(&#123;</span><br><span class="line">          filename: <span class="string">&#x27;[path].gz[query]&#x27;</span>,</span><br><span class="line">          algorithm: <span class="string">&#x27;gzip&#x27;</span>,</span><br><span class="line">          test: <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&#x27;\\.(&#x27;</span> + productionGzipExtensions.join(<span class="string">&#x27;|&#x27;</span>) + <span class="string">&#x27;)$&#x27;</span>),</span><br><span class="line">          threshold: <span class="number">10240</span>,</span><br><span class="line">          minRatio: <span class="number">0.8</span></span><br><span class="line">        &#125;)</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-使用插件压缩混淆去注释"><a href="#2-使用插件压缩混淆去注释" class="headerlink" title="2. 使用插件压缩混淆去注释"></a>2. 使用插件压缩混淆去注释</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TerserPlugin = <span class="built_in">require</span>(<span class="string">&#x27;terser-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  configureWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      config.plugins.push(</span><br><span class="line">        <span class="keyword">new</span> TerserPlugin(&#123;</span><br><span class="line">          cache: <span class="literal">true</span>,</span><br><span class="line">          parallel: <span class="literal">true</span>,</span><br><span class="line">          sourceMap: <span class="literal">false</span>,</span><br><span class="line">          terserOptions: &#123;</span><br><span class="line">            compress: &#123;</span><br><span class="line">              drop_console: <span class="literal">true</span>,</span><br><span class="line">              drop_debugger: <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-去掉多余的第三方库"><a href="#3-去掉多余的第三方库" class="headerlink" title="3. 去掉多余的第三方库"></a>3. 去掉多余的第三方库</h4><p>3.1. 删除库npm指令：npm uninstall xxx</p><p>3.2. 把非必要库放到服务端，如处理时间常用库moment.js，引入比较大，建议放在后端，或者使用代替方案如day.js，有时间精力也可以自行封装方法，但是重复造车轮不推荐。</p><p>3.3. (可选)提取第三方库，不使用import方式引入，而是使用其cdn链接直接在public中的index.html中使用传统方式引入，有利于减少编译包体积。</p><h4 id="4-资源CDN"><a href="#4-资源CDN" class="headerlink" title="4. 资源CDN"></a>4. 资源CDN</h4><p>资源文件CDN，像图片资源我都是放在七牛云储存，从不放服务器，七牛云好像配置域名就可以cdn加速了，比较方便。如果客户端有特殊自定义需要，如全国地址要自行配置，其配置文件也比较大，也要提取出来，不要放客户端中打包。</p><h4 id="5-图片预加载"><a href="#5-图片预加载" class="headerlink" title="5. 图片预加载"></a>5. 图片预加载</h4><p>防止多图或图片较大时对客户端浏览体验产生影响：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">PreLoad</span> </span>&#123;</span><br><span class="line">    private i: number;</span><br><span class="line">    private arr: string[];</span><br><span class="line">    <span class="keyword">constructor</span>(arr: string[]) &#123;</span><br><span class="line">        <span class="built_in">this</span>.i = <span class="number">0</span></span><br><span class="line">        <span class="built_in">this</span>.arr = arr</span><br><span class="line">    &#125;</span><br><span class="line">    public imgs() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> work = <span class="function">(<span class="params">src: string</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.i &lt; <span class="built_in">this</span>.arr.length) &#123;</span><br><span class="line">                    <span class="keyword">const</span> img = <span class="keyword">new</span> Image()</span><br><span class="line">                    img.src = src;</span><br><span class="line">                    <span class="keyword">if</span> (img.complete) &#123;</span><br><span class="line">                        work(<span class="built_in">this</span>.arr[<span class="built_in">this</span>.i++])</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        img.onload = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                            work(<span class="built_in">this</span>.arr[<span class="built_in">this</span>.i++])</span><br><span class="line">                            img.onload = <span class="literal">null</span>;</span><br><span class="line">                        &#125;;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// console.log(((this.i + 1) / this.arr.length) * 100);</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    resolve()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            work(<span class="built_in">this</span>.arr[<span class="built_in">this</span>.i])</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加个转圈菊花或者加载动画/提示等，然后调用该方法来阻塞页面：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> imgs = [<span class="string">&#x27;http://XX.png&#x27;</span>,<span class="string">&#x27;http://XX.png&#x27;</span>]</span><br><span class="line"><span class="keyword">const</span> preload = <span class="keyword">new</span> <span class="built_in">this</span>.$utils.preload(imgs)</span><br><span class="line"><span class="keyword">const</span> preDone = <span class="keyword">await</span> preload.imgs()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>node+TS后端开发实践(环境篇)</title>
      <link href="/2019/09/29/old/node-TS%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5-%E7%8E%AF%E5%A2%83%E7%AF%87/"/>
      <url>/2019/09/29/old/node-TS%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5-%E7%8E%AF%E5%A2%83%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p>主要技术栈：框架选择express，TS语言开发，TS在JS基础上增加了多种数据类型，包括其提供的接口编程、类型检查等特性，非常适合编写后端程序。</p><p>运行：ts-node + webpack + gulp</p><p>部署：webpack + pm2 / supervisor</p><a id="more"></a><p>全局安装Typescript即拥有一个编译器，可以使用tsc编译TS(ts后缀)为浏览器识别的原生js，使用”tsc -w”即可监听目录变化自动编译，源目录及输出目录等配置在项目根目录下tsconfig.json进行配置。</p><p>但是以上并不太适合实际开发中使用，我最终选择的方案为<a href="https://www.npmjs.com/package/ts-node">ts-node</a>作为实例化编译器，开发模式下可在package.json配置”dev”: “ts-node-dev 相对目录启动文件路径”，安装devDependencies下依赖<a href="https://www.npmjs.com/package/ts-node-dev">ts-node-dev</a>，这样运行npm run dev即可启动项目并在终端查看实时代码错误检查。</p><p>编译生产使用webpack方案，webpack.config.js配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mode:<span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">    target:<span class="string">&#x27;node&#x27;</span>,</span><br><span class="line">    entry:<span class="string">&#x27;./src/main.ts&#x27;</span>, <span class="comment">// 启动文件路径</span></span><br><span class="line">    output:&#123;</span><br><span class="line">        path:path.resolve(__dirname,<span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">        filename:<span class="string">&#x27;server.js&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>:&#123;</span><br><span class="line">        rules:[</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.tsx?$/</span>,</span><br><span class="line">                use: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: <span class="string">&#x27;ts-loader&#x27;</span>,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            <span class="comment">// 加快编译速度</span></span><br><span class="line">                            transpileOnly: <span class="literal">true</span>,</span><br><span class="line">                            <span class="comment">// 指定特定的ts编译配置，为了区分脚本的ts配置</span></span><br><span class="line">                            configFile: path.resolve(__dirname, <span class="string">&#x27;./tsconfig.json&#x27;</span>)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">                exclude: <span class="regexp">/node_modules/</span></span><br><span class="line">            &#125;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> NodeJs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动端(ios)日期显示错误问题</title>
      <link href="/2019/03/14/old/%E7%A7%BB%E5%8A%A8%E7%AB%AF(ios)%E6%97%A5%E6%9C%9F%E6%98%BE%E7%A4%BA%E9%94%99%E8%AF%AF%E9%97%AE%E9%A2%98/"/>
      <url>/2019/03/14/old/%E7%A7%BB%E5%8A%A8%E7%AB%AF(ios)%E6%97%A5%E6%9C%9F%E6%98%BE%E7%A4%BA%E9%94%99%E8%AF%AF%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>在ios中日期格式显示不能为”-“，否则会出现错误，H5开发中记得使用正则规避。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> date = <span class="string">&#x27;2019-01-01&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newDate = <span class="keyword">new</span> <span class="built_in">Date</span>(date.replace(<span class="regexp">/-/g</span>, <span class="string">&#x27;/&#x27;</span>))</span><br></pre></td></tr></table></figure><p>此问题只出现在ios，安卓和PC都能识别。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux开机自启Tomcat最简单方法</title>
      <link href="/2019/02/18/old/Linux%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AFTomcat%E6%9C%80%E7%AE%80%E5%8D%95%E6%96%B9%E6%B3%95/"/>
      <url>/2019/02/18/old/Linux%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AFTomcat%E6%9C%80%E7%AE%80%E5%8D%95%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h6 id="1-修改开机自启脚本rc-local：vim-etc-rc-d-rc-local"><a href="#1-修改开机自启脚本rc-local：vim-etc-rc-d-rc-local" class="headerlink" title="1. 修改开机自启脚本rc.local：vim /etc/rc.d/rc.local"></a>1. 修改开机自启脚本rc.local：vim /etc/rc.d/rc.local</h6><p>添加如下内容(java安装路径和tomcat路径根据实际修改)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME&#x3D;&#x2F;home&#x2F;shawn&#x2F;jdk1.8.0_171</span><br><span class="line"></span><br><span class="line">&#x2F;home&#x2F;shawn&#x2F;tomcat7&#x2F;bin&#x2F;startup.sh start</span><br></pre></td></tr></table></figure><h6 id="2-修改rc-local为可执行"><a href="#2-修改rc-local为可执行" class="headerlink" title="2. 修改rc.local为可执行"></a>2. 修改rc.local为可执行</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 &#x2F;etc&#x2F;rc.d&#x2F;rc.local</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于forEach循环的思考与优化</title>
      <link href="/2018/12/16/old/%E5%85%B3%E4%BA%8EforEach%E5%BE%AA%E7%8E%AF%E7%9A%84%E6%80%9D%E8%80%83%E4%B8%8E%E4%BC%98%E5%8C%96/"/>
      <url>/2018/12/16/old/%E5%85%B3%E4%BA%8EforEach%E5%BE%AA%E7%8E%AF%E7%9A%84%E6%80%9D%E8%80%83%E4%B8%8E%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>首先说foreach的优点：书写方便，比原始for循环简洁许多；</p><p>再说下foreach存在的问题：forEach不能使用break跳出循环，使用return false也只会终止代码（效果相当于for的continue），而且在谷歌浏览器中执行效率会比较低一些（苹果浏览器中则相反）。</p><p>总结：foreach适合简单循环出数组的场景，书写方便。而如果需要对数据进行复杂操作，或者数组体积较大时，不建议使用foreach。</p><p>下面谈谈对foreach的一些优化。</p><a id="more"></a><h1 id="1-使用抛出异常来跳出foreach循环"><a href="#1-使用抛出异常来跳出foreach循环" class="headerlink" title="1. 使用抛出异常来跳出foreach循环"></a>1. 使用抛出异常来跳出foreach循环</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let arr &#x3D; [0, 1, &quot;stop&quot;, 3, 4];</span><br><span class="line">try &#123;</span><br><span class="line">    arr.forEach(element &#x3D;&gt; &#123;</span><br><span class="line">        if (element &#x3D;&#x3D;&#x3D; &quot;stop&quot;) &#123;</span><br><span class="line">            throw new Error(&quot;forEachBreak&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(element); &#x2F;&#x2F; 输出 0 1 后面不输出</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">    console.log(e.message); &#x2F;&#x2F; forEachBreak</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上方法使用了try-catch包裹，当循环体过大时性能可能会下降</p><h1 id="2-重写foreach循环方法"><a href="#2-重写foreach循环方法" class="headerlink" title="2. 重写foreach循环方法"></a>2. 重写foreach循环方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.forEach &#x3D; function (fn) &#123;</span><br><span class="line">    for (let i &#x3D; 0; i &lt; this.length; i++) &#123;</span><br><span class="line">        let ret &#x3D; fn(this[i], i, this);</span><br><span class="line">        if (typeof ret !&#x3D;&#x3D; &quot;undefined&quot; &amp;&amp; (ret &#x3D;&#x3D; null || ret &#x3D;&#x3D; false)) break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#39;使return false跳出循环：&#39;);</span><br><span class="line">arr.forEach(element &#x3D;&gt; &#123;</span><br><span class="line">    if (element &#x3D;&#x3D; &#39;stop&#39;) return false</span><br><span class="line">    console.log(element); &#x2F;&#x2F; 输出 0 1 后面不输出</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&#39;return即为continue：&#39;);</span><br><span class="line">arr.forEach(element &#x3D;&gt; &#123;</span><br><span class="line">    if (element &#x3D;&#x3D; &#39;stop&#39;) return</span><br><span class="line">    console.log(element); &#x2F;&#x2F; 0 1 3 4</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>参考资料:  </p></blockquote><ul><li><a href="https://www.imooc.com/wenda/detail/408124">原生forEach原理</a></li><li><a href="https://blog.csdn.net/haochuan9421/article/details/81414532">JS数组循环的性能和效率分析</a></li><li><a href="http://web.jobbole.com/84026/">trycatch对代码运行的性能影响</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端三剑客各种知识点梳理汇总 2</title>
      <link href="/2018/08/04/old/javascript-study/"/>
      <url>/2018/08/04/old/javascript-study/</url>
      
        <content type="html"><![CDATA[<p>JS 相关补充</p><a id="more"></a><h5 id="JavaScript-由以下三部分组成："><a href="#JavaScript-由以下三部分组成：" class="headerlink" title="JavaScript 由以下三部分组成："></a>JavaScript 由以下三部分组成：</h5><ul><li>ECMAScript（核心）：JavaScript 语言基础</li><li>DOM（文档对象模型）：规定了访问HTML和XML的接口</li><li>BOM（浏览器对象模型）：提供了浏览器窗口之间进行交互的对象和方法</li></ul><h5 id="JS内置对象"><a href="#JS内置对象" class="headerlink" title="JS内置对象"></a>JS内置对象</h5><ul><li>数据封装类对象：Object、Array、Boolean、Number、String</li><li>其他对象：Function、Arguments、Math、Date、RegExp、Error</li><li>ES6新增对象：Symbol、Map、Set、Promises、Proxy、Reflect</li></ul><h5 id="一些规范"><a href="#一些规范" class="headerlink" title="一些规范"></a>一些规范</h5><ul><li>代码段使用花括号{}包裹</li><li>变量和函数在使用前进行声明</li><li>以大写字母开头命名构造函数，全大写命名常量</li><li>规范定义JSON对象，补全双引号</li><li>用{}和[]声明对象和数组</li></ul><h5 id="高性能编写注意"><a href="#高性能编写注意" class="headerlink" title="高性能编写注意"></a>高性能编写注意</h5><ul><li>遵循严格模式：”use strict”;</li><li>将js脚本放在页面底部，加快渲染页面</li><li>将js脚本将脚本成组打包，减少请求</li><li>使用非阻塞方式下载js脚本</li><li>尽量使用局部变量来保存全局变量</li><li>尽量减少使用闭包</li><li>使用 window 对象属性方法时，省略 window</li><li>尽量减少对象成员嵌套</li><li>缓存 DOM 节点的访问</li><li>通过避免使用 eval() 和 Function() 构造器</li><li>给 setTimeout() 和 setInterval() 传递函数而不是字符串作为参数</li><li>尽量使用直接量创建对象和数组</li><li>最小化重绘(repaint)和回流(reflow)</li></ul><h5 id="最小化重绘和回流"><a href="#最小化重绘和回流" class="headerlink" title="最小化重绘和回流"></a>最小化重绘和回流</h5><ul><li>需要要对元素进行复杂的操作时，可以先隐藏(display:”none”)，操作完成后再显示</li><li>需要创建多个DOM节点时，使用DocumentFragment创建完后一次性的加入document</li><li>缓存Layout属性值，如：var left = elem.offsetLeft; 这样，多次使用 left 只产生一次回流</li><li>尽量避免用table布局（table元素一旦触发回流就会导致table里所有的其它元素回流）</li><li>避免使用css表达式(expression)，因为每次调用都会重新计算值（包括加载页面）</li><li>尽量使用 css 属性简写，如：用 border 代替 border-width, border-style, border-color</li></ul><h5 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h5><ul><li>在JavaScript中，函数声明与变量声明经常被JavaScript引擎隐式地提升到当前作用域的顶部。</li><li>声明语句中的赋值部分并不会被提升，只有名称被提升</li><li>函数声明的优先级高于变量，如果变量名跟函数名相同且未赋值，则函数声明会覆盖变量声明</li><li>如果函数有多个同名参数，那么最后一个参数（即使没有定义）会覆盖前面的同名参数</li></ul><h5 id="原型原型链"><a href="#原型原型链" class="headerlink" title="原型原型链"></a>原型原型链</h5><ul><li>JavaScript的所有对象中都包含了一个 [proto] 内部属性</li><li>当函数对象作为构造函数创建实例时，prototype 属性值将被作为实例对象的原型 [proto]</li><li>当一个对象调用的属性/方法自身不存在时，就会去自己 [proto] 关联的前辈 prototype 对象上去找</li><li>如果没找到，就会去该 prototype 原型 [proto] 关联的前辈 prototype 去找。依次类推，直到找到属性/方法或 undefined 为止。从而形成了所谓的“原型链”</li><li>JavaScript对象是通过引用来传递的，当修改原型时，与之相关的对象也会继承这一改变（原型特点）</li></ul><h5 id="this对象"><a href="#this对象" class="headerlink" title="this对象"></a>this对象</h5><ul><li>this 总是指向函数的直接调用者</li><li>如果有 new 关键字，this 指向 new 出来的实例对象</li><li>在事件中，this指向触发这个事件的对象</li><li>IE下 attachEvent 中的this总是指向全局对象Window</li></ul><h5 id="DOM的发展"><a href="#DOM的发展" class="headerlink" title="DOM的发展"></a>DOM的发展</h5><ul><li>DOM：文档对象模型（Document Object Model），定义了访问HTML和XML文档的标准，与编程语言及平台无关</li><li>DOM0：提供了查询和操作Web文档的内容API。未形成标准，实现混乱。如：document.forms[‘login’]</li><li>DOM1：W3C提出标准化的DOM，简化了对文档中任意部分的访问和操作。如：JavaScript中的Document对象</li><li>DOM2：原来DOM基础上扩充了鼠标事件等细分模块，增加了对CSS的支持。如：getComputedStyle(elem, pseudo)</li><li>DOM3：增加了XPath模块和加载与保存（Load and Save）模块。如：XPathEvaluator</li></ul><h5 id="事件委托-代理"><a href="#事件委托-代理" class="headerlink" title="事件委托/代理"></a>事件委托/代理</h5><ul><li>是指将事件绑定目标元素的到父元素上，利用冒泡机制触发该事件</li><li>优点：<br>  可以减少事件注册，节省大量内存占用；    可以将事件应用于动态添加的子元素上</li><li>缺点：<br>  使用不当会造成事件在不应该触发时触发</li></ul><h5 id="new操作符做了什么"><a href="#new操作符做了什么" class="headerlink" title="new操作符做了什么"></a>new操作符做了什么</h5><ul><li>创建实例对象，this 变量引用该对象，同时还继承了构造函数的原型</li><li>属性和方法被加入到 this 引用的对象中</li><li>新创建的对象由 this 所引用，并且最后隐式的返回 this</li></ul><h5 id="闭包（closure）"><a href="#闭包（closure）" class="headerlink" title="闭包（closure）"></a>闭包（closure）</h5><ul><li>闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域</li><li>使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念</li></ul><h5 id="闭包的特性"><a href="#闭包的特性" class="headerlink" title="闭包的特性"></a>闭包的特性</h5><ul><li>函数内再嵌套函数</li><li>内部函数可以引用外层的参数和变量</li><li>参数和变量不会被垃圾回收机制回收</li></ul><h5 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h5><ul><li>内存泄漏指任何对象在您不再拥有或需要它之后仍然存在</li><li>垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收</li><li>setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏</li><li>闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）</li></ul><h5 id="Array-slice"><a href="#Array-slice" class="headerlink" title="Array.slice()"></a>Array.slice()</h5><ul><li>“读取”数组指定的元素，不会对原数组进行修改</li><li>arr.slice(start, end)</li></ul><h5 id="Array-splice"><a href="#Array-splice" class="headerlink" title="Array.splice()"></a>Array.splice()</h5><ul><li>“操作”数组指定的元素，会修改原数组，返回被删除的元素</li><li>语法：arr.splice(index, count, [insert Elements])</li><li>index 是操作的起始位置</li><li>count = 0 插入元素，count &gt; 0 删除元素</li><li>[insert Elements] 向数组新插入的元素</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript波澜起伏的一生</title>
      <link href="/2018/07/08/old/see-javascript/"/>
      <url>/2018/07/08/old/see-javascript/</url>
      
        <content type="html"><![CDATA[<p>JavaScript俨然是目前热度最高的编程语言之一，作为前端开发在工作中总离不开写JS，但有些疑问总在我脑海中：它与Java到底什么关系？所谓的ES、TS又是什么？在查阅一番资料后，我以拙略的文笔记录下这篇文章，一起走进JS的前世今生吧。</p><h3 id="LiveScript"><a href="#LiveScript" class="headerlink" title="LiveScript"></a>LiveScript</h3><p>说到JavaScript的起源，就不得不和web的发展联系到一块，起初由于网页的大小和复杂性不断提升，在频繁的表单验证之间存在的数据交换过程只会带来负担，于是美国网景公司(Netscape)开始着手开发一种浏览器上的脚本语言，用于处理简单的验证，它就是LiveScript，但这并不是最终发布时的正式名称。</p><h3 id="Java’s-Script"><a href="#Java’s-Script" class="headerlink" title="Java’s Script ?"></a>Java’s Script ?</h3><p>我们都知道Java与JavaScript语言本身并无关系，网上普遍说法是JavaScript为了蹭Java的热度而如此命名，但这种说法有失偏颇，因为当时Java也是才刚刚推出的编程语言，其火爆也应该是后话了。</p><p>实际上因为Sun公司所大肆宣传的“一次编写，到处运行”对网景公司影响很大（想想这种客户端脚本语言不也是一样只要有浏览器环境就可以到处运行吗，比如现在流行的利用前端技术进行跨终端开发，我认为本质很接近，不管你是什么手机，平板，电脑，其他终端设备，只要有浏览器内核就行），于是两家公司建立了联盟，LiveScript改名为JavaScript，后来Java确实越来越火，网景毕竟主要还是做浏览器，当然很愿意让JavaScript搭上这趟顺风车，这个商标顺理成章也就归属Sun公司了。</p><p>这个似乎要发展成为”简化版Java“的网页脚本语言由当时网景公司的布兰登·艾奇负责编写，但这位程序员偏偏不是Java的Fans，所以几乎是以应付工作的心态，仅用了10天就把第一版JavaScript设计完成，谁又能想到如今JS会大火，这也算是导致了JS本身存在一些问题受开发者诟病的原因之一，但话说回来，当时也只是以“简单的脚本语言”为目标设计出来的编程语言而已，这可能就是所谓的 伟大事业往往都有一个渺小的开端吧。</p><h3 id="一切才刚刚开始"><a href="#一切才刚刚开始" class="headerlink" title="一切才刚刚开始"></a>一切才刚刚开始</h3><p>说到这里我们已经大致了解，JavaScript就是网景公司与Sun公司联合推行的一款客户端脚本语言，目的解决网页中的简单验证等需求，它由网景公司的一名程序员设计。但我们看到JS发展到如今已经跟一开始天差地别，时代在不停推动着JS，那么其中是谁来主导JS前行呢？是其发行者网景公司吗？遗憾的是网景公司其实在2003年就已解散，说到底网景公司主要的产品是旗下一款浏览器，而我们现在并未看到过网景浏览器，因为它在第一次浏览器大战中就完全败给了微软旗下的IE，在当时IE占据了整个浏览器市场份额的96%，网景没有丝毫扭转机会。没错，虽然JavaScript获得了巨大的成功，可网景公司最终却走向了失败。</p><h3 id="JScript-CEnvi"><a href="#JScript-CEnvi" class="headerlink" title="JScript? CEnvi?"></a>JScript? CEnvi?</h3><p>在网景公司推出JavaScript不久后，微软在IE3浏览器中也加入了名为JScript的JavaScript实现，与JScript类似的还有CEnvi，这就意味着不同的浏览器厂商将会实现不同的脚本语言，JavaScript的标准化问题被提上了议事日程。</p><p>当时网景公司将 JavaScript1.1 提交由国际标准化组织ECMA制定统一规范，而后ECMA组织制定了JavaScript的统一规范，命名为ECMAScript，发展到现在，一直由各个互联网行业前沿的公司一起参与规范制定，而所有浏览器将遵循这套规范统一去实现。</p><h3 id="ECMAScript-序"><a href="#ECMAScript-序" class="headerlink" title="ECMAScript 序"></a>ECMAScript 序</h3><p>网景公司早已不存在，而当初一起推行JavaScript的Sun公司呢？后来被甲骨文公司收购合并，甲骨文公司得到了Java的所有权，所以JavaScript也变成了甲骨文公司的注册商标，这就很尴尬了，不知道什么时候起，我们写的“JavaScript”已不再是原本的JavaScript，这种浏览器脚本语言其实根本上并没有一个准确的名字（比如微软就更希望它叫做JScript），或者说它以前叫做过JavaScript，但现在还能说是吗？而大家还是习惯叫它JavaScript，可能是约定俗成的存在。就好像我们老说H5开发，大家就知道是指HTML5开发，其实HTML本来就是简写了，H5这种说法明显是不科学的，要这样我说C3开发你能联想到我说的是CSS3开发吗？没这种说法吧，但是说H5开发就可以，我们很多人都不会意识到有什么不对，因为习惯了。</p><p>所以我的个人理解是，我们现在写的所谓的“JS”，并不能完全称之为ES，我们知道了ECMAScript是JavaScript的规范，而“JS”是由浏览器去实现的，各个浏览器虽然都遵循ES规范，但实现的程度、所支持的情况还是各不一样，规范只有一套，浏览器却不止一种，终究无法天下大同。遇到同样一段“JS”代码，在谷歌浏览器中完美运行，在IE上面就各种错误，我们认为是你写的代码有问题，这种问题我们称之为“兼容性问题”。而web网页开发中处理兼容性问题也成为了一项重要的工作内容。</p><h3 id="ECMAScript6"><a href="#ECMAScript6" class="headerlink" title="ECMAScript6"></a>ECMAScript6</h3><p>关于JavaScript和ECMAScript到这里基本就讲完了，总之JavaScript（或简称JS）是一个历史遗留下来的统称，由于它的这段发展史特殊，跟其他编程语言不同，它自身的版本更迭应该以ECMAScript这个规范为主。而其中数ES6（ECMAScript第六版）最为磨难，从ES3之后存在的一些激进的想法，一直到ES5都未能完全实现，最后在ES6中才修改完毕发布，所以也说ES6是革命性的一版，此后JS进入了一个高速发展的阶段，很多代码在低版本浏览器未必支持运行或者并未实现，所以现在前端开发中经常需要使用到一些编译工具，将代码最终编译成浏览器均可识别的代码，这里不做过多赘述。</p><p>前端编程发展至今，一直在规避以往复杂低效等问题，“面向浏览器编程”这一特性也许一直是种制约，但毫无疑问总体依然在向新的编程体验不断迈进，路漫漫其修远兮。</p><h3 id="TypeScript-面向未来开发"><a href="#TypeScript-面向未来开发" class="headerlink" title="TypeScript - 面向未来开发"></a>TypeScript - 面向未来开发</h3><p>如果你对TypeScript感到陌生，那应该是还没有使用过Angular，Angular是由谷歌开发的一款前端框架，是目前较为流行的框架之一，其本身从2.0版本开始使用TypeScript编写，而TypeScript来头也不小，是由微软开发的一套语言，扩展了JavaScript的语法和特性，同时也支持ES6规范，TS+Angular的组合感觉十分强悍，毕竟背后是微软和谷歌两大公司，但同时这套组合也让我感觉到学习成本相对陡峭，比如相对于vue来说。</p><p>当然TypeScript因为是JS的超集所以无法直接运行于浏览器的，也是需要编译，TS有专门的编译器。</p><h3 id="题外：JQuery-刀耕火种的前端时代"><a href="#题外：JQuery-刀耕火种的前端时代" class="headerlink" title="题外：JQuery - 刀耕火种的前端时代"></a>题外：JQuery - 刀耕火种的前端时代</h3><p>JQuery本身是非常优秀的JS框架，在大量传统JS框架类库中最具代表性，甚至因为太过流行，很多初学者连JS都没搞明白是啥就开始先学习JQ，产生这种现象的原因，是Jquery框架太过流行导致的先入为主，而究其根本，还是因为JavaScript本身发展的原因，前面提到JavaScript在开始设计时就没考虑那么多，而不同的浏览器又有不同的实现，导致各种兼容问题，可以说JS本身就是问题重重，想想大好时间居然花在各种测试兼容上面是有多浪费，所以Jq为代表的这些框架类库自然就崛起了，打开Jq在github上的主页，我们可以看到6k+commit，共270+开发者为其贡献代码，复杂的事情和麻烦的兼容就交给框架去处理，加上Jq本身的设计就非常优秀，所以能在很长一段时间火爆。或许懒才是推动发展的源泉，真正的懒人总会去思考怎样把复杂的问题简单化，而编程的魅力往往也尽在其中。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人生苦短，ES6我只想现在就了解他</title>
      <link href="/2018/06/20/old/ES6-study/"/>
      <url>/2018/06/20/old/ES6-study/</url>
      
        <content type="html"><![CDATA[<p>从零开始的 ECMAScript 6 不完全攻略，轻扫盲向</p><!-- ![](http://img.palxp.com/blog/ECMAScript6.png) --><a id="more"></a><h3 id="0-块级作用域"><a href="#0-块级作用域" class="headerlink" title="0. 块级作用域"></a>0. 块级作用域</h3><blockquote><p>let变量在不同块级作用域中不影响：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (let i &#x3D; 1; i &lt; 3; i++) &#123;</span><br><span class="line">  console.log(i);</span><br><span class="line">&#125;</span><br><span class="line">console.log(i); &#x2F;&#x2F; 此行将报错: ReferenceError 未定义</span><br></pre></td></tr></table></figure><blockquote><p>重复声明变量会导致无法编译：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; 1;</span><br><span class="line">let a &#x3D; 2; &#x2F;&#x2F; 此行将报错</span><br></pre></td></tr></table></figure><blockquote><p>一次声明后无法再次赋值的const类型：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const PI &#x3D; 3.1415926; &#x2F;&#x2F; 必须在声明时就立刻赋值</span><br><span class="line">PI &#x3D; 2; &#x2F;&#x2F; 此行将报错，const类型值不可改变</span><br></pre></td></tr></table></figure><blockquote><p>const声明并非不可修改，而是不可重新赋值</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const k &#x3D; [] &#x2F;&#x2F; 引用类型依然可以修改</span><br><span class="line">k.b &#x3D; 1;</span><br><span class="line">k.a &#x3D; 2;</span><br><span class="line">console.log(k); &#x2F;&#x2F; 输出[b: 1, a: 2]</span><br><span class="line">k&#x3D;[]; &#x2F;&#x2F; 此行将报错，const声明的变量不可重新赋值</span><br></pre></td></tr></table></figure><h3 id="1-数组扩展"><a href="#1-数组扩展" class="headerlink" title="1. 数组扩展"></a>1. 数组扩展</h3><blockquote><p>将一串字符转换为数组</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let arr &#x3D; Array.of(3,4,7,9,11);</span><br><span class="line">console.log(arr); &#x2F;&#x2F; [3, 4, 7, 9, 11]</span><br></pre></td></tr></table></figure><blockquote><p>将其他对象转换为数组</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let set1 &#x3D; new Set();</span><br><span class="line">set1.add(1).add(2).add(3)</span><br><span class="line">console.log(Array.from(set1)) &#x2F;&#x2F; [1,2,3] map array一样同理</span><br></pre></td></tr></table></figure><blockquote><p>数组加工</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let t &#x3D; Array.from([1,3,5], (i) &#x3D;&gt; i*2)</span><br><span class="line">console.log(t);&#x2F;&#x2F; 输出 [2,6,10]</span><br><span class="line">    </span><br><span class="line">let t &#x3D; Array.from([1,2,3], function(i)&#123;return i+1&#125;)</span><br><span class="line">console.log(t);&#x2F;&#x2F; 输出 [2,3,4]</span><br></pre></td></tr></table></figure><blockquote><p>数组遍历 entries()、keys()、values()</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">for (let index of [&#39;a&#39;, &#39;b&#39;].keys()) &#123;</span><br><span class="line">    console.log(index);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 0</span><br><span class="line">&#x2F;&#x2F; 1</span><br><span class="line">for (let elem of [&#39;a&#39;, &#39;b&#39;].values()) &#123;</span><br><span class="line">    console.log(elem);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; &#39;a&#39;</span><br><span class="line">&#x2F;&#x2F; &#39;b&#39;</span><br><span class="line">for (let [index, elem] of [&#39;a&#39;, &#39;b&#39;].entries()) &#123;</span><br><span class="line">    console.log(index, elem);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 0 &quot;a&quot;</span><br><span class="line">&#x2F;&#x2F; 1 &quot;b&quot;</span><br></pre></td></tr></table></figure><h3 id="2-对象扩展"><a href="#2-对象扩展" class="headerlink" title="2. 对象扩展"></a>2. 对象扩展</h3><blockquote><p>ES5 与 ES6 中写法对比</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; 1;</span><br><span class="line">let b &#x3D; 2;</span><br><span class="line">    </span><br><span class="line">let es5 &#x3D; &#123;</span><br><span class="line">    a:a,</span><br><span class="line">    b:b</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line">let es6 &#x3D; &#123;</span><br><span class="line">    a,</span><br><span class="line">    b</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>数组方法表示更简明</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let es5_method &#x3D; &#123;</span><br><span class="line">    hello: function() &#123;</span><br><span class="line">      console.log(&#39;hello&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line">let es6_method &#x3D; &#123;</span><br><span class="line">    hello() &#123;</span><br><span class="line">      console.log(&#39;hello&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>属性表达式 可以在对象中使用变量定义，这在ES5以前不行</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; &#39;b&#39;;</span><br><span class="line">let obj &#x3D; &#123; [a]: 1 &#125;;</span><br><span class="line">console.log(obj); &#x2F;&#x2F; &#123; b: 1&#125;</span><br></pre></td></tr></table></figure><blockquote><p>新增API</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#39;字符串&#39;,Object.is(&#39;abc&#39;,&#39;abc&#39;),&#39;abc&#39;&#x3D;&#x3D;&#x3D;&#39;abc&#39;);</span><br><span class="line">console.log(&#39;数组&#39;,Object.is([],[]),[]&#x3D;&#x3D;&#x3D;[]);</span><br><span class="line">console.log(&#39;拷贝&#39;,Object.assign(&#123;a:&#39;a&#39;&#125;,&#123;b:&#39;b&#39;&#125;));</span><br></pre></td></tr></table></figure><h3 id="3-函数扩展"><a href="#3-函数扩展" class="headerlink" title="3. 函数扩展"></a>3. 函数扩展</h3><blockquote><p>参数默认值</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function test(x, y &#x3D; &#39;world&#39;)&#123;</span><br><span class="line">    console.log(&#39;默认值&#39;,x,y);</span><br><span class="line">&#125;</span><br><span class="line">test(&#39;hello&#39;); &#x2F;&#x2F; &#39;hello world&#39;</span><br><span class="line">test(&#39;hello&#39;,&#39;you&#39;); &#x2F;&#x2F; &#39;hello you&#39;</span><br></pre></td></tr></table></figure><blockquote><p>可以使用数组形式接收若干参数</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function test(...arg)&#123;</span><br><span class="line">    for(let one of arg)&#123;</span><br><span class="line">      console.log(one);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>箭头函数</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let arrow &#x3D; a &#x3D;&gt; a*2; &#x2F;&#x2F; 带参数</span><br><span class="line">let arrow2 &#x3D; () &#x3D;&gt; 5; &#x2F;&#x2F; 无参</span><br></pre></td></tr></table></figure><blockquote><p>尾调用 可解决递归带来的资源消耗</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function tail(x)&#123;</span><br><span class="line">    console.log(&#39;tail&#39;,x);</span><br><span class="line">&#125;</span><br><span class="line">function fx(x)&#123;</span><br><span class="line">    return tail(x)</span><br><span class="line">&#125;</span><br><span class="line">fx(123)</span><br></pre></td></tr></table></figure><h3 id="4-数组解构赋值"><a href="#4-数组解构赋值" class="headerlink" title="4. 数组解构赋值"></a>4. 数组解构赋值</h3><blockquote><p>变量交换将不再需要中间变量</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; 1;</span><br><span class="line">let b &#x3D; 2;</span><br><span class="line">[a,b] &#x3D; [b,a];</span><br><span class="line">console.log(a,b); &#x2F;&#x2F; a&#x3D;2 b&#x3D;1</span><br></pre></td></tr></table></figure><blockquote><p>更直观的变量赋值</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a,b;</span><br><span class="line">[a,b] &#x3D; [1,2];</span><br><span class="line">console.log(a,b); &#x2F;&#x2F; a&#x3D;1, b&#x3D;2</span><br></pre></td></tr></table></figure><blockquote><p>可以选择性接收参数</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a,b;</span><br><span class="line">[a,,,b] &#x3D; [1,2,3,4,5];</span><br><span class="line">console.log(a,b); &#x2F;&#x2F; a&#x3D;1, b&#x3D;4</span><br></pre></td></tr></table></figure><blockquote><p>也可以是数组</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a,b;</span><br><span class="line">[a,,...b] &#x3D; [1,2,3,4,5]; &#x2F;&#x2F; 注意这里 ... 的作用</span><br><span class="line">console.log(a,b); &#x2F;&#x2F; a&#x3D;1, b&#x3D;[3,4,5]</span><br></pre></td></tr></table></figure><h3 id="5-对象解构赋值"><a href="#5-对象解构赋值" class="headerlink" title="5. 对象解构赋值"></a>5. 对象解构赋值</h3><blockquote><p>按key value匹配</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let o &#x3D; &#123;q:42,p:true,c:99&#125;;</span><br><span class="line">let &#123;p&#x3D;false,q,k&#x3D;0,c&#125; &#x3D; o;</span><br><span class="line">console.log(p,q,k,c);</span><br><span class="line"></span><br><span class="line">let &#123;a&#x3D;10,b&#x3D;5&#125;&#x3D;&#123;a:3&#125;;</span><br><span class="line">console.log(a,b);</span><br></pre></td></tr></table></figure><blockquote><p>使用场景模拟</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let metaData&#x3D;&#123;</span><br><span class="line">    title:&#39;abc&#39;,</span><br><span class="line">    test:[&#123;</span><br><span class="line">      title:&#39;test&#39;,</span><br><span class="line">      desc:&#39;description&#39;</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br><span class="line">let &#123;title:esTitle,test:[&#123;title:cnTitle&#125;]&#125;&#x3D;metaData;</span><br><span class="line">console.log(esTitle,cnTitle); &#x2F;&#x2F; abc test</span><br><span class="line">&#x2F;&#x2F; let &#123;title,test&#125; &#x3D; metaData;</span><br><span class="line">&#x2F;&#x2F; console.log(title,test[0].title);</span><br></pre></td></tr></table></figure><h3 id="6-新数据类型-symbol"><a href="#6-新数据类型-symbol" class="headerlink" title="6. 新数据类型 symbol"></a>6. 新数据类型 symbol</h3><blockquote><p>具有唯一性</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let a1 &#x3D; Symbol();</span><br><span class="line">let a2 &#x3D; Symbol();</span><br><span class="line">console.log(a1&#x3D;&#x3D;&#x3D;a2); &#x2F;&#x2F; false</span><br><span class="line">let a3 &#x3D; Symbol.for(&#39;a3&#39;);&#x2F;&#x2F;寻找a3，找不到，创建</span><br><span class="line">let a4 &#x3D; Symbol.for(&#39;a3&#39;);&#x2F;&#x2F;寻找a3，找到，赋值</span><br><span class="line">console.log(a3&#x3D;&#x3D;&#x3D;a4); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><blockquote><p>使用场景模拟</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">let a1 &#x3D; Symbol.for(&#39;abc&#39;);</span><br><span class="line">let obj &#x3D; &#123;</span><br><span class="line">    [a1]:&#39;123&#39;,</span><br><span class="line">    &#39;abc&#39;:345,</span><br><span class="line">    &#39;c&#39;:456</span><br><span class="line">&#125;;</span><br><span class="line">console.log(obj);&#x2F;&#x2F;&#123;abc: 345, c: 456, Symbol(abc): &quot;123&quot;&#125;</span><br><span class="line">    </span><br><span class="line">for(let [key,value] of Object.entries(obj))&#123;</span><br><span class="line">    console.log(&#39;let of&#39;,key,value);</span><br><span class="line">    &#x2F;&#x2F; let of abc 345</span><br><span class="line">    &#x2F;&#x2F; let of c 456</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">Object.getOwnPropertySymbols(obj).forEach(function(item)&#123;</span><br><span class="line">    console.log(obj[item]); &#x2F;&#x2F; 123</span><br><span class="line">&#125;)</span><br><span class="line">    </span><br><span class="line">Reflect.ownKeys(obj).forEach(function(item)&#123;</span><br><span class="line">    console.log(&#39;ownkeys&#39;,item,obj[item]);</span><br><span class="line">    &#x2F;&#x2F; ownkeys abc 345</span><br><span class="line">    &#x2F;&#x2F; ownkeys c 456</span><br><span class="line">    &#x2F;&#x2F; ownkeys Symbol(abc) 123</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="7-数据结构set与map"><a href="#7-数据结构set与map" class="headerlink" title="7. 数据结构set与map"></a>7. 数据结构set与map</h3><blockquote><p>set的元素唯一特性(可做数组去重)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr &#x3D; [1,1,1,4,5];</span><br><span class="line">let list &#x3D; new Set(arr);</span><br><span class="line">console.log(list.size); &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure><blockquote><p>set中比较是使用严等于，数据类型不转换</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr &#x3D; [1,2,3,1,&#39;2&#39;];</span><br><span class="line">let list2 &#x3D; new Set(arr);</span><br><span class="line">console.log(list2); &#x2F;&#x2F; &#123;1, 2, 3, &quot;2&quot;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>通过增删改查来比较 Map Set Array Object</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">let map &#x3D; new Map();</span><br><span class="line">let set &#x3D; new Set();</span><br><span class="line">let arr &#x3D; [];</span><br><span class="line">let obj &#x3D; &#123;&#125;;</span><br><span class="line">let temp &#x3D; &#123;a:1&#125;;</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F; 增</span><br><span class="line">map.set(&#39;a&#39;,1);</span><br><span class="line">    </span><br><span class="line">set.add(temp);</span><br><span class="line">    </span><br><span class="line">arr.push(&#123;a:1&#125;);</span><br><span class="line">    </span><br><span class="line">obj.a&#x3D;1; &#x2F;&#x2F; obj[&#39;a&#39;]&#x3D;1;</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F; 删</span><br><span class="line">    </span><br><span class="line">map.delete(&#39;a&#39;);</span><br><span class="line">    </span><br><span class="line">set.forEach(item &#x3D;&gt; item.a ? delete(item.a) : null);&#x2F;&#x2F; set.delet(temp)</span><br><span class="line">    </span><br><span class="line">let index &#x3D; arr.findIndex(item &#x3D;&gt; item.a);</span><br><span class="line">arr.splice(index, 1);</span><br><span class="line">    </span><br><span class="line">delete obj.a;&#x2F;&#x2F; delete obj[&#39;a&#39;]</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F; 改</span><br><span class="line">    </span><br><span class="line">map.set(&#39;a&#39;,2);</span><br><span class="line">    </span><br><span class="line">set.forEach(item &#x3D;&gt; item.a ? item.a&#x3D;2 : null);&#x2F;&#x2F; temp.a &#x3D; 2;</span><br><span class="line">    </span><br><span class="line">arr.forEach(item &#x3D;&gt; item.a ? item.a&#x3D;2 : null);</span><br><span class="line">    </span><br><span class="line">obj.a &#x3D; 2;&#x2F;&#x2F; obj[&#39;a&#39;]&#x3D;2;</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F; 查</span><br><span class="line">let map_exist &#x3D; map.has(&#39;a&#39;);</span><br><span class="line"></span><br><span class="line">let set_exist &#x3D; set.has(&#123;a:1&#125;);&#x2F;&#x2F;false</span><br><span class="line">let set_exist1 &#x3D; set.has(temp);&#x2F;&#x2F;true</span><br><span class="line"></span><br><span class="line">let arr_exist &#x3D; arr.find(item &#x3D;&gt; item.a);</span><br><span class="line"></span><br><span class="line">let obj_exist &#x3D; &#39;a&#39; in obj;</span><br></pre></td></tr></table></figure><h3 id="8-对象代理一"><a href="#8-对象代理一" class="headerlink" title="8. 对象代理一"></a>8. 对象代理一</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let obj&#x3D;&#123;</span><br><span class="line">    time:&#39;2018-06-18&#39;,</span><br><span class="line">    name:&#39;old&#39;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line">console.log(Reflect.get(obj,&#39;time&#39;));&#x2F;&#x2F; 2018-06-18</span><br><span class="line">Reflect.set(obj,&#39;name&#39;,&#39;new&#39;);</span><br><span class="line">Reflect.deleteProperty(obj, &#39;time&#39;);</span><br><span class="line">console.log(obj);&#x2F;&#x2F; &#123;name: &quot;new&quot;&#125;</span><br><span class="line">console.log(Reflect.has(obj,&#39;name&#39;));&#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><h3 id="9-类的实现"><a href="#9-类的实现" class="headerlink" title="9. 类的实现"></a>9. 类的实现</h3><blockquote><p>父类生成</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Parent&#123;</span><br><span class="line">    &#x2F;&#x2F; 构造函数</span><br><span class="line">    constructor(name&#x3D;&#39;fa&#39;)&#123;</span><br><span class="line">      this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 实例化</span><br><span class="line">let a &#x3D; new Parent();</span><br></pre></td></tr></table></figure><blockquote><p>子类继承</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Child extends Parent&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">let b &#x3D; new Child();</span><br></pre></td></tr></table></figure><blockquote><p>继承传递参数</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Child extends Parent&#123;</span><br><span class="line">    constructor(name2&#x3D;&#39;child&#39;)&#123;</span><br><span class="line">      super(name2); &#x2F;&#x2F; 相当于向父类构造函数传参，需写在最前</span><br><span class="line">      this.type &#x3D; &#39;child&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">let c &#x3D; new Child(&#39;new&#39;);</span><br><span class="line">console.log(c); &#x2F;&#x2F; &#123;name: &quot;new&quot;, type: &quot;child&quot;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Getter Setter</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Parent&#123;</span><br><span class="line">    constructor(name&#x3D;&#39;js&#39;)&#123;</span><br><span class="line">      this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    get longName()&#123;</span><br><span class="line">      return &#39;get:&#39;+this.name</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    set longName(value)&#123;</span><br><span class="line">      this.name&#x3D;value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">let v &#x3D; new Parent();</span><br><span class="line">console.log(&#39;getter&#39;,v.longName); &#x2F;&#x2F; getter get:js</span><br><span class="line">    </span><br><span class="line">v.longName&#x3D;&#39;javascript&#39;;</span><br><span class="line">console.log(&#39;setter&#39;,v.longName); &#x2F;&#x2F; setter get:javascript</span><br></pre></td></tr></table></figure><blockquote><p>静态方法</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Parent&#123;</span><br><span class="line">    static say()&#123;</span><br><span class="line">      console.log(&#39;hello world&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">Parent.tell(); &#x2F;&#x2F; hello world</span><br></pre></td></tr></table></figure><blockquote><p>静态属性</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Parent&#123;    </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">Parent.type&#x3D;&#39;test&#39;;</span><br><span class="line">    </span><br><span class="line">console.log(Parent.type); &#x2F;&#x2F; test</span><br></pre></td></tr></table></figure><h3 id="10-Promise"><a href="#10-Promise" class="headerlink" title="10. Promise"></a>10. Promise</h3><blockquote><p>一个模拟的回调函数案例</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">let callback &#x3D; (code) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;开始运行&#39;);</span><br><span class="line">    return new Promise( (resolve,reject) &#x3D;&gt; &#123;</span><br><span class="line">        setTimeout(function () &#123;</span><br><span class="line">            if (code &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">                resolve(&#39;正常运行&#39;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                reject(&#39;参数错误&#39;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, 1000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let test &#x3D; 0;</span><br><span class="line"></span><br><span class="line">callback(test)</span><br><span class="line">    .then(( msg ) &#x3D;&gt; &#123;</span><br><span class="line">        console.log( msg );</span><br><span class="line">        return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">            setTimeout(function () &#123;</span><br><span class="line">                resolve(&#39;继续执行&#39;);</span><br><span class="line">            &#125;, 1500);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(( msg ) &#x3D;&gt; &#123;</span><br><span class="line">        console.log( msg );</span><br><span class="line">        console.log(&#39;全部执行完毕&#39;);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch((e) &#x3D;&gt; &#123;</span><br><span class="line">        console.log(e);</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F; 假设 test &#x3D; 0 时控制台输出：</span><br><span class="line">&#x2F;&#x2F; 开始运行</span><br><span class="line">&#x2F;&#x2F; 正常运行 (1s后)</span><br><span class="line">&#x2F;&#x2F; 继续执行 (1.5s后)</span><br><span class="line">&#x2F;&#x2F; 全部执行完毕 (1.5s后)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 假设 test &#x3D; 1 时控制台输出：</span><br><span class="line">&#x2F;&#x2F; 开始运行</span><br><span class="line">&#x2F;&#x2F; 参数错误 (1s后)</span><br></pre></td></tr></table></figure><h3 id="11-模块化"><a href="#11-模块化" class="headerlink" title="11. 模块化"></a>11. 模块化</h3><blockquote><p>a.js中导出</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let CL &#x3D; &#39;R&#39;;</span><br><span class="line">let fn &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;a function&#39;);</span><br><span class="line">&#125;</span><br><span class="line">class Test&#123;</span><br><span class="line">  test()&#123;</span><br><span class="line">    console.log(&#39;a class&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  CL,</span><br><span class="line">  Test,</span><br><span class="line">  fn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>b.js中引入</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import all from &#39;.&#x2F;b.js&#39;;</span><br><span class="line"></span><br><span class="line">console.log(all.CL); &#x2F;&#x2F; R</span><br><span class="line"></span><br><span class="line">all.fn(); &#x2F;&#x2F; a function</span><br><span class="line"></span><br><span class="line">let t1 &#x3D; new all.Test();</span><br><span class="line">t1.test(); &#x2F;&#x2F; a class</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次将js模块发布到npm包过程</title>
      <link href="/2018/05/16/old/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%8F%91%E5%B8%83npm%E6%A8%A1%E5%9D%97%E8%BF%87%E7%A8%8B/"/>
      <url>/2018/05/16/old/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%8F%91%E5%B8%83npm%E6%A8%A1%E5%9D%97%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>什么是npm？npm是nodejs上集成的原第三方包管理工具</p><a id="more"></a><h5 id="0-注册npm账号"><a href="#0-注册npm账号" class="headerlink" title="0. 注册npm账号"></a>0. 注册npm账号</h5><p><a href="https://www.npmjs.com/">https://www.npmjs.com/</a></p><h5 id="1-查看npm镜像，如果之前更换过，需要重置"><a href="#1-查看npm镜像，如果之前更换过，需要重置" class="headerlink" title="1. 查看npm镜像，如果之前更换过，需要重置"></a>1. 查看npm镜像，如果之前更换过，需要重置</h5><pre><code>npm config get registry</code></pre><h5 id="1-1-重置镜像路径-墙内的同学都习惯用淘宝镜像，这将不能访问npm账号"><a href="#1-1-重置镜像路径-墙内的同学都习惯用淘宝镜像，这将不能访问npm账号" class="headerlink" title="1.1 重置镜像路径(墙内的同学都习惯用淘宝镜像，这将不能访问npm账号)"></a>1.1 重置镜像路径(墙内的同学都习惯用淘宝镜像，这将不能访问npm账号)</h5><pre><code>npm config set registry https://registry.npmjs.org</code></pre><h5 id="1-2-之后有必要可以再切回来"><a href="#1-2-之后有必要可以再切回来" class="headerlink" title="1.2 之后有必要可以再切回来"></a>1.2 之后有必要可以再切回来</h5><pre><code>npm config set registry https://registry.npm.taobao.org</code></pre><h5 id="2-创建你的npm包"><a href="#2-创建你的npm包" class="headerlink" title="2. 创建你的npm包"></a>2. 创建你的npm包</h5><p>在项目的git仓库下执行：</p><pre><code>npm init</code></pre><p>根据提示输入npm包信息，<code>package.json</code>创建完毕。</p><blockquote><p>name：项目的包名，先在npm官网搜索下，或者npm install你想用的包名，以免名称已存在。<br><br>version：版本号，以后更新也要用到。<br><br>entry point：也就是项目main入口，默认根目录的index.js，调用这个包首先访问的文件。<br><br>其他选项不是很重要，后面也可以直接修改<code>package.json</code>文件。</p></blockquote><h5 id="3-在终端登录npm"><a href="#3-在终端登录npm" class="headerlink" title="3. 在终端登录npm"></a>3. 在终端登录npm</h5><pre><code>npm adduser</code></pre><p>输入npm账号的用户名、密码、邮箱，登录成功：</p><pre><code>Logged in as xxx on https://registry.npmjs.org/.</code></pre><h5 id="4-发布npm包"><a href="#4-发布npm包" class="headerlink" title="4. 发布npm包"></a>4. 发布npm包</h5><pre><code>npm publish</code></pre><blockquote><p>第一次执行可能会提示：you must verify your email before publishing a new package: <a href="https://www.npmjs.com/email-edit">https://www.npmjs.com/email-edit</a>，按照提示打开这个网址，输入第2步配置的邮箱，然后登录邮箱点击邮件进行验证即可。</p></blockquote><h5 id="5-获取npm包"><a href="#5-获取npm包" class="headerlink" title="5. 获取npm包"></a>5. 获取npm包</h5><p>可以先创建一个空目录尝试：</p><pre><code>npm install &lt;package-name&gt;</code></pre><p>下载完包后根目录创建一个<code>test.js</code>：</p><pre><code>var t = require(&#39;xxx&#39;) // xxx为包名console.log(t)</code></pre><p>运行<code>node test</code>，控制台输出正常。</p><h5 id="6-更新npm包"><a href="#6-更新npm包" class="headerlink" title="6. 更新npm包"></a>6. 更新npm包</h5><p>修改<code>package.json</code>中的版本号，同样执行:</p><pre><code>npm publish</code></pre><h5 id="7-撤销npm包"><a href="#7-撤销npm包" class="headerlink" title="7. 撤销npm包"></a>7. 撤销npm包</h5><p>理论上npm包具有唯一性不可删除，已发布无法撤销只能更新，但是可以执行以下命令来提示该包不再维护：</p><pre><code>npm deprecate xxx(包名) &#39;这个包我已经不再维护了&#39;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端三剑客各种知识点梳理汇总 1</title>
      <link href="/2018/04/08/old/html-css-js/"/>
      <url>/2018/04/08/old/html-css-js/</url>
      
        <content type="html"><![CDATA[<p>CSS JS 常见总集篇</p><a id="more"></a><blockquote><p>掌握html语义化，避免通篇div<br>扎实css基础 <br><br>    1. 提升可访问性；<br>    2. SEO；<br>    3. 结构清晰，利于维护；</p></blockquote><h2 id="1-css页面布局"><a href="#1-css页面布局" class="headerlink" title="1. css页面布局"></a>1. css页面布局</h2><p>题目一：高度已知，三栏布局，左右栏固定宽度，中间自适应</p><pre><code>1. float浮动布局2. absolute绝对定位布局，左右固定好width，左侧设置left:0，中间设置left与right为左右width宽度，右侧设置right:03. flex布局，左右宽度固定，中间设置flex:14. table表格布局，左右设置宽度固定5. grid网格布局---- 课题延伸 ----优缺点 / 比较1.  缺点：float脱离文档流，需要处理清除浮动    优点：兼容性好2.  缺点：子元素都将脱离文档流，使用性比较差    优点：快捷，不容易出问题3.  缺点：存在兼容性问题    优点：较新型解决方案，解决以上两种布局的不足4.  缺点：存在历史诟病问题    优点：使用简单，兼容性好5.    缺点：可能存在兼容问题    优点：较新型解决方案，可实现多种复杂布局，起源是栅格布局高度改变(某栏内容撑开容器)时哪个布局将不适用：float溢出部分样式出错；absolute依据内容撑开所在栏，其他栏不会变flex布局自适应改变（可用）table布局自适应改变（可用）grid布局不随内容改变，内容直接溢出真实开发中哪个最实用？</code></pre><h2 id="2-css盒模型"><a href="#2-css盒模型" class="headerlink" title="2. css盒模型"></a>2. css盒模型</h2><p>标准模型+IE模型，两种模型区别</p><pre><code>margin    border        padding            content        padding    bordermargin</code></pre><p>标准模型：</p><pre><code>height * width = content</code></pre><p>IE模型：</p><pre><code>height * width = content + padding + border</code></pre><p>css如何设置两种模型:</p><pre><code>box-sizing: content-box (浏览器默认)box-sizing: border-box</code></pre><p>js获取模型宽高：</p><pre><code>dom.style.width / height （只能取元素内联的样式）dom.currentStyle.width / height （获取渲染后的值，但只有IE支持）dom.getComputedStyle(dom).width / height （兼容性好，获取实际宽高）dom.getBoundingClientRect().width / height （获取实际宽高，以及相对位置）</code></pre><p>边距重叠问题（父子元素 / 相邻元素）：</p><pre><code>BFC 块级格式化上下文overflow: hidden / auto;</code></pre><h2 id="3-DOM事件类"><a href="#3-DOM事件类" class="headerlink" title="3. DOM事件类"></a>3. DOM事件类</h2><p>Dom事件级别（不同时期的标准）：</p><pre><code>DOM0 : element.onclick=function()&#123;&#125;DOM1 : 没有制定过跟事件相关的标准DOM2 : element.addEventListener(&#39;click&#39;,function()&#123;&#125;,false)DOM3 : element.addEventListener(&#39;keyup&#39;,function()&#123;&#125;,false) 相比DOM2多出一些键盘鼠标事件等类型</code></pre><p>Dom事件模型（捕获 / 冒泡）：</p><p>事件流（浏览器与用户交互响应）：</p><pre><code>捕获 ↓    目标元素     冒泡 ↑</code></pre><p>描述DOM事件捕获具体流程：</p><pre><code>window -&gt; document -&gt; html(document.documentElement) -&gt; body(document.body) -&gt; HTML结构 目标元素</code></pre><p>Event对象的常见应用：</p><pre><code>event.preventDefault()    阻止默认事件（比如阻止点击a标签会触发页面跳转）event.stopPropagation()    阻止冒泡事件（点击子元素时阻止触发父级元素冒泡）event.stoplmmediatePropagation()    事件响应优先级（同时注册两个事件时阻止另一个事件触发）event.currentTarget    事件代理 当前触发事件的对象event.target    事件代理 获取点击的元素对象</code></pre><p>自定义事件：</p><pre><code>var eve = new Event(&#39;custome&#39;) // 只定义了事件名var eve2 = new CustomeEvent(&#39;custome&#39;, obj) // 可传参// 注册事件document.addEventListener(&#39;custome&#39;, function()&#123;    ....&#125;)// 触发事件document.dispatchEvent(eve)    </code></pre><p>自定义事件 :<br>    true表示捕获阶段触发 false表示冒泡阶段触发</p><h2 id="4-原型链类"><a href="#4-原型链类" class="headerlink" title="4. 原型链类"></a>4. 原型链类</h2><h4 id="创建对象有几种方法"><a href="#创建对象有几种方法" class="headerlink" title="创建对象有几种方法"></a>创建对象有几种方法</h4><pre><code>1. 字面量    var o1 = &#123;xx:&#39;&#39;&#125;    var o11 = new Object(&#123;xx:&#39;&#39;&#125;)2. 构造函数    var M = function(xx)&#123;this.xx=xx&#125;    var o2 = new M(&#39;&#39;)3. Object.create    var P = &#123;xx:&#39;&#39;&#125;    var o3 = Object.create(P)</code></pre><h4 id="原型、构造函数、实例、原型链"><a href="#原型、构造函数、实例、原型链" class="headerlink" title="原型、构造函数、实例、原型链"></a>原型、构造函数、实例、原型链</h4><blockquote><pre><code>构造函数 -- new &gt;&gt; 实例对象 -- _proto_ &gt;&gt; 原型对象&lt;br&gt;    | prototype (系统自动加上的属性)&lt;br&gt;原型对象.constructor</code></pre></blockquote><p>原理：共享原型对象，实例通过原型链找到方法</p><h5 id="instanceof的原理"><a href="#instanceof的原理" class="headerlink" title="instanceof的原理"></a>instanceof的原理</h5><pre><code>                    instanceof    实例对象.__proto__  ---&gt;  构造函数.prototype    实例对象.__proto__  --constructor--&gt; 构造函数</code></pre><h5 id="new运算符"><a href="#new运算符" class="headerlink" title="new运算符"></a>new运算符</h5><pre><code>    一个新对象被创建，继承foo.prototype    var new2 = function (func) &#123;        var o = Object.cteate(func.prototype)        var result = func.call(o)        if (typeof result === &#39;object&#39;) &#123;            return result        &#125; else return o    &#125;</code></pre><h2 id="5-面向对象"><a href="#5-面向对象" class="headerlink" title="5. 面向对象"></a>5. 面向对象</h2><p>类的声明</p><pre><code>ES5：function Animal() &#123;  this.name = &#39;name&#39;&#125;ES6：class Animal2 &#123;  constructor () &#123;    this.name = name  &#125;&#125;</code></pre><p> 实例化</p><pre><code>new Animal() ......</code></pre><p> 借助构造函数实现部分继承</p><pre><code>function Parent(params) &#123;  this.name = &#39;parent&#39;&#125;function Child(params) &#123;  Parent.call(this) // /apply  this.type = &#39;child&#39;&#125;// 存在问题：无法继承原型对象上的方法</code></pre><p>借助原型链实现继承</p><pre><code>function Child2(params) &#123;  this.type = &#39;child2&#39;&#125;Child2.prototype = new Parent()// 存在问题：操作实例对象改变的是同一个原型对象，会导致其他实例对象也发生改变</code></pre><p>组合后解决以上问题</p><pre><code>function Child3() &#123;    Parent.call(this)    this.type = &#39;child3&#39;&#125;Child3.prototype = new Parent()// 存在问题：构造函数被多余执行</code></pre><p>组合优化写法</p><pre><code>function Child4() &#123;    Parent.call(this)    this.type = &#39;child4&#39;&#125;Child4.prototype = Parent.prototype // 引用类型// 存在问题：共用了父类的原型对象</code></pre><p>组合优化写法2</p><pre><code>function Child5() &#123;    Parent.call(this)    this.type = &#39;child5&#39;&#125;Child5.prototype = Object.create(Parent.prototype)Child5.prototype.constructor = Child5</code></pre><h2 id="6-通信类"><a href="#6-通信类" class="headerlink" title="6. 通信类"></a>6. 通信类</h2><h6 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h6><pre><code>限制从一个源加载的文档或脚本与来自另一个源的资源进行交互隔离潜在恶意脚本</code></pre><h6 id="前后端如何通信"><a href="#前后端如何通信" class="headerlink" title="前后端如何通信"></a>前后端如何通信</h6><pre><code>AjaxWebSocketCORS</code></pre><h6 id="如何创建Ajax"><a href="#如何创建Ajax" class="headerlink" title="如何创建Ajax"></a>如何创建Ajax</h6><ul><li>XMLHttpRequest对象的工作流程</li><li>兼容性的处理</li><li>事件的触发条件和顺序</li></ul><h2 id="7-安全类"><a href="#7-安全类" class="headerlink" title="7. 安全类"></a>7. 安全类</h2><h6 id="CSRF-跨站请求伪造"><a href="#CSRF-跨站请求伪造" class="headerlink" title="CSRF 跨站请求伪造"></a>CSRF 跨站请求伪造</h6><pre><code>攻击原理    网站B中引诱用户点击链接，向网站A发起请求    网站A中某一接口存在漏洞    用户登录过该网站A，本地存在着cookie防御措施    token验证    referer验证（页面来源）    隐藏令牌</code></pre><h6 id="XSS-跨域脚本攻击"><a href="#XSS-跨域脚本攻击" class="headerlink" title="XSS 跨域脚本攻击"></a>XSS 跨域脚本攻击</h6><pre><code>往页面注入脚本插入js不执行</code></pre><h2 id="8-算法类"><a href="#8-算法类" class="headerlink" title="8. 算法类"></a>8. 算法类</h2><h6 id="0-排序"><a href="#0-排序" class="headerlink" title="0. 排序"></a>0. 排序</h6><ul><li><a href="http://segmentfault.com/a/1190000009426421">快速排序</a></li><li>选择排序</li><li>希尔排序</li><li>冒泡排序</li></ul><h6 id="1-堆栈、队列、链表"><a href="#1-堆栈、队列、链表" class="headerlink" title="1. 堆栈、队列、链表"></a>1. <a href="http://juejin.im/entry/58759e79128fe1006b48cdfd">堆栈、队列、链表</a></h6><h6 id="2-递归"><a href="#2-递归" class="headerlink" title="2. 递归"></a>2. <a href="http://segmentfault.com/a/1190000009857470">递归</a></h6><h6 id="3-波兰式和逆波兰式"><a href="#3-波兰式和逆波兰式" class="headerlink" title="3. 波兰式和逆波兰式"></a>3. 波兰式和逆波兰式</h6><h2 id="9-渲染机制"><a href="#9-渲染机制" class="headerlink" title="9. 渲染机制"></a>9. 渲染机制</h2><h6 id="DOCTYPE"><a href="#DOCTYPE" class="headerlink" title="DOCTYPE"></a>DOCTYPE</h6><pre><code>    告诉浏览器当前什么文档类型，浏览器根据此选择解析方式    HTML5        &lt;!DOCTYPE html&gt;    HTML4.01        严格模式:不解析已废弃的元素        传统模式</code></pre><ul><li>浏览器渲染过程</li><li>重排</li><li>重绘</li><li>布局</li></ul><h2 id="10-JS运行机制"><a href="#10-JS运行机制" class="headerlink" title="10. JS运行机制"></a>10. JS运行机制</h2><h6 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h6><h6 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h6><p>同步任务 while for ..<br>异步任务 setTimeOut setinterval promise ..</p><pre><code>        异步任务被挂起，同步任务执行完后异步任务进入队列    for(i=0;i&lt;4;i++)&#123;        setTimeOut(function()&#123;            console.log(i)        &#125;,1000)    &#125; // 结果为间隔一秒后输出4次4</code></pre><h2 id="11-页面性能"><a href="#11-页面性能" class="headerlink" title="11. 页面性能"></a>11. 页面性能</h2><h6 id="资源压缩合并，减少HTTP请求"><a href="#资源压缩合并，减少HTTP请求" class="headerlink" title="资源压缩合并，减少HTTP请求"></a>资源压缩合并，减少HTTP请求</h6><h6 id="非核心代码的异步加载"><a href="#非核心代码的异步加载" class="headerlink" title="非核心代码的异步加载"></a>非核心代码的异步加载</h6><pre><code>    异步加载方式：        1. 动态脚本加载        2. defer (script标签属性)        3. async (同上)    区别：        defer在HTML解析完之后执行，会按顺序执行        async在加载完成后立即执行，不一定会按顺序</code></pre><h6 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h6><pre><code>        强缓存 Expires Cache-Control        协商缓存 Last-Modified Etag If-None-Match</code></pre><h6 id="CDN加速"><a href="#CDN加速" class="headerlink" title="CDN加速"></a>CDN加速</h6><h6 id="预解析DNS-https默认关闭了预解析，需要添加meta开启"><a href="#预解析DNS-https默认关闭了预解析，需要添加meta开启" class="headerlink" title="预解析DNS (https默认关闭了预解析，需要添加meta开启)"></a>预解析DNS (https默认关闭了预解析，需要添加meta开启)</h6><pre><code>    &lt;link rel=&quot;dns-prefetch&quot; herf=&quot;&quot;&gt;</code></pre><h2 id="12-错误监控"><a href="#12-错误监控" class="headerlink" title="12. 错误监控"></a>12. 错误监控</h2><p>即时运行错误的捕获方式</p><pre><code>try..catchwindow.onerror</code></pre><p>资源加载错误</p><pre><code>object.onerrorperformance.getEntries() Error事件捕获 widow.addEventListener(&#39;error&#39;,func..)</code></pre><p>上报错误</p><pre><code>(new Image()).src = &#39;http://xx.com/?a=1&#39;</code></pre><h2 id="题外"><a href="#题外" class="headerlink" title="题外"></a>题外</h2><p>业务能力</p><pre><code>做过什么业务负责的业务有什么业绩使用了什么技术方案突破了什么技术难点遇到了什么问题最大的收获</code></pre><p>团队协作能力</p><p>其他</p><pre><code>乐观积极 主动沟通 逻辑顺畅 上进有责任心 有主张 做事果断职业竞争力    业务能力  行业前列    思考能力  同一事物多思考最优解    学习能力  不断学习新技术，沉淀总结职业规划    目标是什么：业务上成为专家，技术上成为行业大牛    近阶段目标：不断学习积累各方面经验    长期目标：做几件有价值的事情，如开源作品，技术框架    方式方法：先完成业务，做到极致，逐步向目标靠拢希望公司能提供什么：技术分享会；对于开发可以给到相关平台工具权限等资源</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch小试牛刀：各种查询语句整理</title>
      <link href="/2018/01/20/old/ElasticSearch%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80/"/>
      <url>/2018/01/20/old/ElasticSearch%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80/</url>
      
        <content type="html"><![CDATA[<p>部分笔记 不完全指北 ElasticSearch版本更迭很快，所作记录可能有些偏差</p><a id="more"></a><h5 id="查看所有索引"><a href="#查看所有索引" class="headerlink" title="查看所有索引"></a>查看所有索引</h5><pre><code>GET /_cat/indices?v</code></pre><h5 id="创建一个索引demo"><a href="#创建一个索引demo" class="headerlink" title="创建一个索引demo"></a>创建一个索引demo</h5><pre><code>PUT one_index &#123;  &quot;mappings&quot;: &#123;    &quot;type_name&quot;: &#123;      &quot;properties&quot;: &#123;         &quot;title&quot;:    &#123;            &quot;type&quot;: &quot;text&quot;,            &quot;fields&quot;: &#123;              &quot;keyword&quot;: &#123;                &quot;type&quot;: &quot;keyword&quot;,                &quot;ignore_above&quot;: 256              &#125;            &#125;            &#125;,         &quot;name&quot;:     &#123; &quot;type&quot;: &quot;text&quot;  &#125;,         &quot;age&quot;:      &#123; &quot;type&quot;: &quot;integer&quot; &#125;,          &quot;created&quot;:  &#123;          &quot;type&quot;:   &quot;date&quot;,           &quot;format&quot;: &quot;strict_date_optional_time||epoch_millis&quot;        &#125;      &#125;    &#125;  &#125;&#125;</code></pre><h5 id="插入-更新文档"><a href="#插入-更新文档" class="headerlink" title="插入/更新文档"></a>插入/更新文档</h5><pre><code>PUT(或POST) one_index/type_name/1&#123;    &quot;title&quot;: &quot;ceshi&quot;,     &quot;name&quot;: &quot; mingzi&quot;,     &quot;age&quot;: 12,      &quot;created&quot;: 1515549710&#125;</code></pre><h5 id="查看索引类型结构"><a href="#查看索引类型结构" class="headerlink" title="查看索引类型结构"></a>查看索引类型结构</h5><pre><code>GET one_index/type_name/_mapping</code></pre><h5 id="mapping基本类型"><a href="#mapping基本类型" class="headerlink" title="mapping基本类型"></a>mapping基本类型</h5><p><code>text</code>(原string), <code>keyword</code>, <code>date</code>, <code>long</code>, <code>double</code>, <code>boolean</code> , <code>ip</code></p><h5 id="创建结构"><a href="#创建结构" class="headerlink" title="创建结构"></a>创建结构</h5><pre><code>PUT /one_index&#123;  &quot;mappings&quot;: &#123;    &quot;type_name&quot; : &#123;      &quot;properties&quot; : &#123;        &quot;user_id&quot; : &#123;          &quot;type&quot; :   &quot;long&quot;        &#125;      &#125;    &#125;  &#125;&#125;</code></pre><h5 id="创建-更新结构"><a href="#创建-更新结构" class="headerlink" title="创建/更新结构"></a>创建/更新结构</h5><pre><code>PUT /one_index/_mapping/type_name&#123;  &quot;properties&quot; : &#123;    &quot;user_id&quot; : &#123;        &quot;type&quot; :   &quot;long&quot;    &#125;  &#125;&#125;</code></pre><h5 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h5><pre><code>Delete order_index</code></pre><h5 id="删除多个索引"><a href="#删除多个索引" class="headerlink" title="删除多个索引"></a>删除多个索引</h5><pre><code>DELETE /index_one,index_two</code></pre><h5 id="空查询"><a href="#空查询" class="headerlink" title="空查询"></a>空查询</h5><pre><code>GET /_search &#123;&#125;GET /index_/type1,type2/_search &#123;&#125;GET /_search&#123;    &quot;query&quot;: &#123;        &quot;match_all&quot;: &#123;&#125;    &#125;&#125;</code></pre><h5 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h5><pre><code>GET /_search&#123;  &quot;from&quot;: 30,  &quot;size&quot;: 10&#125;</code></pre><h5 id="match查询"><a href="#match查询" class="headerlink" title="match查询"></a>match查询</h5><pre><code>tips:如果你在一个全文字段上使用 match 查询，在执行查询前，它将用正确的分析器去分析查询字符串如果在一个精确值的字段上使用它， 例如数字、日期、布尔或者一个 not_analyzed 字符串字段，那么它将会精确匹配给定的值GET /_search&#123;    &quot;query&quot;: &#123;        &quot;match&quot;: &#123;            &quot;tweet&quot;: &quot;elasticsearch&quot;        &#125;    &#125;&#125;</code></pre><h5 id="multi-match"><a href="#multi-match" class="headerlink" title="multi_match"></a>multi_match</h5><pre><code>tips:查询可以在多个字段上执行相同的 match 查询GET /_search&#123;    &quot;query&quot;: &#123;        &quot;multi_match&quot;: &#123;            &quot;query&quot;:    &quot;full text search&quot;,            &quot;fields&quot;:   [ &quot;title&quot;, &quot;body&quot; ]        &#125;    &#125;    &#125;</code></pre><h5 id="range-查询"><a href="#range-查询" class="headerlink" title="range 查询"></a>range 查询</h5><pre><code>GET /_search&#123;    &quot;query&quot;: &#123;        &quot;range&quot;: &#123;            &quot;age&quot;: &#123;                &quot;gte&quot;:  20,                &quot;lt&quot;:   30            &#125;        &#125;    &#125;&#125;</code></pre><h5 id="term查询"><a href="#term查询" class="headerlink" title="term查询"></a>term查询</h5><pre><code>tips:用于精确值 匹配，这些精确值可能是数字、时间、布尔或者那些 not_analyzed 的字符串GET /_search&#123;    &quot;query&quot;: &#123;         &quot;term&quot;: &#123; &quot;age&quot;: 26 &#125;    &#125;&#125;</code></pre><h5 id="terms查询"><a href="#terms查询" class="headerlink" title="terms查询"></a>terms查询</h5><pre><code>tips:terms 查询和 term 查询一样，但它允许你指定多值进行匹配。如果这个字段包含了指定值中的任何一个值，那么这个文档满足条件GET /_search&#123;    &quot;query&quot;: &#123;         &quot;terms&quot;: &#123;             &quot;tag&quot;: [ &quot;search&quot;, &quot;full_text&quot;, &quot;nosql&quot; ]         &#125;    &#125;&#125;</code></pre><h5 id="exists-查询"><a href="#exists-查询" class="headerlink" title="exists 查询"></a>exists 查询</h5><pre><code>tips:用于查找那些指定字段中有值 (exists) 的文档GET /_search&#123;    &quot;query&quot;: &#123;         &quot;exists&quot;: &#123;             &quot;field&quot;:    &quot;title&quot;        &#125;    &#125;&#125;</code></pre><h5 id="missing-查询"><a href="#missing-查询" class="headerlink" title="missing 查询"></a>missing 查询</h5><pre><code>tips:用于查找那些指定字段中无值 (missing) 的文档GET /_search&#123;    &quot;query&quot;: &#123;         &quot;missing&quot;: &#123;             &quot;field&quot;:    &quot;title&quot;        &#125;    &#125;&#125;</code></pre><h5 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h5><pre><code>tips:</code></pre><blockquote><pre><code>- must 文档 必须 匹配这些条件才能被包含进来。- must_not 文档 必须不 匹配这些条件才能被包含进来。- should 如果满足这些语句中的任意语句，将增加 _score ，否则，无任何影响。它们主要用于修正每个文档的相关性得分。- filter 必须 匹配，但它以不评分、过滤模式来进行。这些语句对评分没有贡献，只是根据过滤标准来排除或包含文档。</code></pre></blockquote><pre><code>GET /_search&#123;    &quot;query&quot; : &#123;         &quot;bool&quot;: &#123;              &quot;must&quot;: &#123;                 &quot;match&quot;: &#123; &quot;part_name&quot;: &quot;保险&quot; &#125;             &#125;,             &quot;must_not&quot; : &#123;                 &quot;match&quot;: &#123; &quot;create_person&quot; : &quot;STDINGSUN2&quot; &#125;             &#125;,             &quot;should&quot; : &#123;                 &quot;range&quot; : &#123; &quot;price1&quot; : &#123; &quot;gte&quot; : 1000&#125; &#125;             &#125;         &#125;    &#125;&#125;</code></pre><h5 id="评分查询"><a href="#评分查询" class="headerlink" title="评分查询"></a>评分查询</h5><pre><code>tips:用于你只需要执行一个 filter 而没有其它查询GET /_search&#123;    &quot;query&quot; : &#123;         &quot;constant_score&quot;:   &#123;            &quot;filter&quot;: &#123;                &quot;term&quot;: &#123; &quot;category&quot;: &quot;ebooks&quot; &#125;             &#125;        &#125;    &#125;&#125;</code></pre><h5 id="验证查询语句"><a href="#验证查询语句" class="headerlink" title="验证查询语句"></a>验证查询语句</h5><pre><code>GET /gb/tweet/_validate/query或( GET /gb/tweet/_validate/query?explain )：带解释&#123;   &quot;query&quot;: &#123;      &quot;tweet&quot; : &#123;         &quot;match&quot; : &quot;really powerful&quot;      &#125;   &#125;&#125;</code></pre><h5 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h5><pre><code>GET /_search&#123;    &quot;query&quot; : &#123;         &quot;bool&quot; : &#123;             &quot;filter&quot; : &#123;                 &quot;match&quot; : &#123;                     &quot;create_person&quot; : &quot;GD001&quot;                 &#125;             &#125;         &#125;    &#125;,    &quot;sort&quot; : &#123; &quot;@timestamp&quot; : &#123; &quot;order&quot; : &quot;desc&quot; &#125; &#125;&#125;</code></pre><h5 id="多级排序查询"><a href="#多级排序查询" class="headerlink" title="多级排序查询"></a>多级排序查询</h5><pre><code>GET /_search&#123;    &quot;query&quot; : &#123;        &quot;bool&quot; : &#123;            &quot;must&quot;:   &#123; &quot;match&quot;: &#123; &quot;tweet&quot;: &quot;manage text search&quot; &#125;&#125;,            &quot;filter&quot; : &#123; &quot;term&quot; : &#123; &quot;user_id&quot; : 2 &#125;&#125;        &#125;    &#125;,    &quot;sort&quot;: [        &#123; &quot;date&quot;:   &#123; &quot;order&quot;: &quot;desc&quot; &#125;&#125;,        &#123; &quot;_score&quot;: &#123; &quot;order&quot;: &quot;desc&quot; &#125;&#125;    ]&#125;</code></pre><h5 id="字段多值的排序查询"><a href="#字段多值的排序查询" class="headerlink" title="字段多值的排序查询"></a>字段多值的排序查询</h5><pre><code>tips:对于数字或日期，你可以将多值字段减为单值，这可以通过使用 min 、 max 、 avg 或是 sum 排序模式GET /_search&#123;    &quot;query&quot; : &#123;        &quot;sort&quot;: &#123;            &quot;dates&quot;: &#123;                &quot;order&quot;: &quot;asc&quot;,                &quot;mode&quot;:  &quot;min&quot;            &#125;    &#125;&#125;</code></pre><h5 id="查询（获取特定的字段）"><a href="#查询（获取特定的字段）" class="headerlink" title="查询（获取特定的字段）"></a>查询（获取特定的字段）</h5><pre><code>GET /_search&#123;    &quot;query&quot;:   &#123; &quot;match_all&quot;: &#123;&#125;&#125;,    &quot;_source&quot;: [ &quot;title&quot;, &quot;created&quot; ]&#125;</code></pre><h5 id="查询（去除-source）"><a href="#查询（去除-source）" class="headerlink" title="查询（去除_source）"></a>查询（去除_source）</h5><pre><code>GET /_search&#123;    &quot;_source&quot;: false,    &quot;query&quot; : &#123;        &quot;term&quot; : &#123; &quot;user&quot; : &quot;kimchy&quot; &#125;    &#125;&#125;</code></pre><h5 id="查询（过滤某些字段）"><a href="#查询（过滤某些字段）" class="headerlink" title="查询（过滤某些字段）"></a>查询（过滤某些字段）</h5><pre><code>GET /_search&#123;    &quot;_source&quot;: &#123;        &quot;includes&quot;: [ &quot;obj1.*&quot;, &quot;obj2.*&quot; ],        &quot;excludes&quot;: [ &quot;*.description&quot; ]    &#125;,    &quot;query&quot; : &#123;        &quot;term&quot; : &#123; &quot;user&quot; : &quot;kimchy&quot; &#125;    &#125;&#125;</code></pre><h5 id="复杂域数据类型"><a href="#复杂域数据类型" class="headerlink" title="复杂域数据类型"></a>复杂域数据类型</h5><p>多值域 </p><pre><code>    eq : &#123; &quot;tag&quot;: [ &quot;search&quot;, &quot;nosql&quot; ]&#125;</code></pre><p>空域</p><pre><code>    eq :     &quot;null_value&quot;:               null,    &quot;empty_array&quot;:              [],    &quot;array_with_null_value&quot;:    [ null ]</code></pre><p>多层级对象</p><pre><code>    &#123;        &quot;tweet&quot;:            &quot;Elasticsearch is very flexible&quot;,        &quot;user&quot;: &#123;            &quot;id&quot;:           &quot;@johnsmith&quot;,            &quot;gender&quot;:       &quot;male&quot;,            &quot;age&quot;:          26,            &quot;name&quot;: &#123;                &quot;full&quot;:     &quot;John Smith&quot;,                &quot;first&quot;:    &quot;John&quot;,                &quot;last&quot;:     &quot;Smith&quot;            &#125;        &#125;    &#125;</code></pre><h5 id="动态映射"><a href="#动态映射" class="headerlink" title="动态映射"></a>动态映射</h5><blockquote><p>如果遇到新字段，对象 my_type 就会抛出异常<br>而内部对象 stash 遇到新字段就会动态创建新字段</p></blockquote><pre><code>    可以用 dynamic 配置来控制这种行为 ，可接受的选项如下：    true   动态添加新的字段--缺省    false    忽略新的字段    strict    如果遇到新字段抛出异常    tips:配置参数 dynamic 可以用在根 object 或任何 object 类型的字段上。         你可以将 dynamic 的默认值设置为 strict , 而只在指定的内部对象中开启它    PUT /my_index    &#123;        &quot;mappings&quot;: &#123;            &quot;my_type&quot;: &#123;                &quot;dynamic&quot;:      &quot;strict&quot;,                 &quot;properties&quot;: &#123;                    &quot;title&quot;:  &#123; &quot;type&quot;: &quot;string&quot;&#125;,                    &quot;stash&quot;:  &#123;                        &quot;type&quot;:     &quot;object&quot;,                        &quot;dynamic&quot;:  true                     &#125;                &#125;            &#125;        &#125;    &#125;</code></pre><h5 id="自定义动态映射"><a href="#自定义动态映射" class="headerlink" title="自定义动态映射"></a>自定义动态映射</h5><h6 id="日期检查"><a href="#日期检查" class="headerlink" title="日期检查"></a>日期检查</h6><p>当 Elasticsearch 遇到一个新的字符串字段时，它会检测这个字段是否包含一个可识别的日期，比如 2014-01-01 。 如果它像日期，这个字段就会被作为 date 类型添加。否则，它会被作为 string 类型添加。</p><pre><code>日期检测可以通过在根对象上设置 date_detection 为 false 来关闭    PUT /my_index&#123;    &quot;mappings&quot;: &#123;        &quot;my_type&quot;: &#123;            &quot;date_detection&quot;: false        &#125;    &#125;&#125;</code></pre><h5 id="动态模板"><a href="#动态模板" class="headerlink" title="动态模板"></a>动态模板</h5><pre><code>模板按照顺序来检测es ：以 _es 结尾的字段名需要使用 spanish 分词器。en ：所有其他字段使用 english 分词器。PUT /my_index&#123;    &quot;mappings&quot;: &#123;        &quot;my_type&quot;: &#123;            &quot;dynamic_templates&quot;: [                &#123; &quot;es&quot;: &#123;                      &quot;match&quot;:              &quot;*_es&quot;,                       &quot;match_mapping_type&quot;: &quot;string&quot;,                      &quot;mapping&quot;: &#123;                          &quot;type&quot;:           &quot;string&quot;,                          &quot;analyzer&quot;:       &quot;spanish&quot;                      &#125;                &#125;&#125;,                &#123; &quot;en&quot;: &#123;                      &quot;match&quot;:              &quot;*&quot;,                       &quot;match_mapping_type&quot;: &quot;string&quot;,                      &quot;mapping&quot;: &#123;                          &quot;type&quot;:           &quot;string&quot;,                          &quot;analyzer&quot;:       &quot;english&quot;                      &#125;                &#125;&#125;            ]&#125;&#125;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Logstash-input-jdbc实现与MySql解耦同步数据到ES</title>
      <link href="/2018/01/16/old/logstash-input-jdbc%E5%AE%9E%E7%8E%B0%E4%B8%8Emysql%E8%A7%A3%E8%80%A6%E5%90%8C%E6%AD%A5%E6%95%B0%E6%8D%AE%E5%88%B0ES/"/>
      <url>/2018/01/16/old/logstash-input-jdbc%E5%AE%9E%E7%8E%B0%E4%B8%8Emysql%E8%A7%A3%E8%80%A6%E5%90%8C%E6%AD%A5%E6%95%B0%E6%8D%AE%E5%88%B0ES/</url>
      
        <content type="html"><![CDATA[<p>随着业务数据的增长，Mysql压力增大，单表储存会严重影响读写的高效性，为解决这一问题，分表分库和历史数据迁移等解决方案就应运而生了，但在某些场景下这些解决方案还是存在问题，例如聚合查询等。而ElasticSearch作为实时的分布式搜索和分析引擎，能够快速查询和处理海量数据，高可用可扩展，通过ES，可以轻松做到保证查询效率的聚合查询，已有不少大型互联网企业成功使用案例，是值得一试的技术。</p><a id="more"></a><p>经过调研，实现与Mysql同步工具基本有以下几种：</p><ul><li>logstash-input-jdbc：官方推荐的插件，Ruby编写的</li><li>go-mysql-elastic：Go编写，国内作者</li><li>python-mysql-replication: Python编写</li><li>elasticsearch-jdbc：Java编写</li><li>elasticsearch-river-mysql：听说已经很少维护</li></ul><h3 id="0-安装-ElasticSearch"><a href="#0-安装-ElasticSearch" class="headerlink" title="0. 安装 ElasticSearch"></a>0. 安装 ElasticSearch</h3><p>参考 <a href="http://blog.palxp.com/2018/01/16/%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8EElasticSearch%E5%85%A5%E9%97%A8%E5%B0%8F%E8%AE%B0/">上一篇文章</a> 此处不做详述。</p><h3 id="1-下载-Logstash"><a href="#1-下载-Logstash" class="headerlink" title="1. 下载 Logstash"></a>1. 下载 Logstash</h3><p>官网链接： <a href="https://www.elastic.co/downloads/logstash">Download Logstash</a>  以6.1.1版本为例：</p><pre><code>wget https://artifacts.elastic.co/downloads/logstash/logstash-6.1.1.zip# 等待下载完毕，执行解压unzip logstash-6.1.1.zip</code></pre><h3 id="2-安装-logstash-input-jdbc-插件"><a href="#2-安装-logstash-input-jdbc-插件" class="headerlink" title="2. 安装 logstash-input-jdbc 插件"></a>2. 安装 logstash-input-jdbc 插件</h3><p>进入解压好的目录 <code>cd logstash-6.1.1</code></p><p>root用户执行：<code>sudo bin/logstash-plugin install logstash-input-jdbc</code></p><blockquote><p>补充：后面查阅一些文章说logstash5.x以上版本自带了这个插件，但我已经安装了，就不再验证，这里应该可以直接略过此步，后面如果报错再回来折腾。</p></blockquote><p>安装过程会有点慢，我在本地一次成功了，服务器上卡在<code>Installing logstash-input-jdbc</code>不动，第二天早上又试了下又成功了，如果一直不行尝试以下方法，执行：</p><pre><code>cd logstash-6.1.1wget https://github.com/logstash-plugins/logstash-input-jdbc/archive/v4.3.1.zipunzip logstash-input-jdbc-4.3.1.zipcd logstash-input-jdbc-4.3.1/</code></pre><p>再执行：</p><pre><code>vi Gemfile</code></pre><p>修改 source 的值 为： <code>&quot;https://ruby.taobao.org&quot;</code> 或 <code>&quot;https://gems.ruby-china.org&quot;</code></p><p>保存完继续执行：</p><pre><code>vi logstash-input-jdbc.gemspec</code></pre><p>找到这一行：</p><pre><code>s.files = `git ls-files`.split($\)</code></pre><p>改为：</p><pre><code>s.files = [&quot;.gitignore&quot;, &quot;CHANGELOG.md&quot;, &quot;Gemfile&quot;, &quot;LICENSE&quot;, &quot;NOTICE.TXT&quot;, &quot;README.md&quot;, &quot;Rakefile&quot;, &quot;lib/logstash/inputs/jdbc.rb&quot;, &quot;lib/logstash/plugin_mixins/jdbc.rb&quot;, &quot;logstash-input-jdbc.gemspec&quot;, &quot;spec/inputs/jdbc_spec.rb&quot;]</code></pre><p>继续执行：</p><pre><code>gem build logstash-input-jdbc.gemspeccd ..bin/plugin install logstash-input-jdbc-4.3.1.gem</code></pre><blockquote><p>参考文章：<a href="http://blog.csdn.net/q15150676766/article/details/75949679">http://blog.csdn.net/q15150676766/article/details/75949679</a></p><p>该方法属于手动安装，需要你指定插件版本，参照<a href="https://www.elastic.co/guide/en/logstash/current/plugins-inputs-jdbc.html">plugins-inputs-jdbc官方文档</a>查看插件当前的最新版本号。</p></blockquote><h3 id="3-关联Mysql数据库"><a href="#3-关联Mysql数据库" class="headerlink" title="3. 关联Mysql数据库"></a>3. 关联Mysql数据库</h3><p>下载一个mysql连接jar包：<a href="http://central.maven.org/maven2/mysql/mysql-connector-java/6.0.6/mysql-connector-java-6.0.6.jar">mysql-connector-java-6.0.6</a></p><p>进入logstash创建一个conf文件，执行：</p><pre><code>cd logstash-6.1.1/configvim jdbc.conf</code></pre><p>编辑粘贴以下内容：</p><pre><code>input &#123;    jdbc &#123;        # 刚才下载的jar包路径        jdbc_driver_library =&gt;&quot;/opt/mysql-connector-java-6.0.6.jar&quot;        jdbc_driver_class =&gt;&quot;com.mysql.jdbc.Driver&quot;        # 数据库地址        jdbc_connection_string =&gt;&quot;jdbc:mysql://192.168.0.1:3306/myTest?characterEncoding=UTF-8&amp;useSSL=false&quot;        jdbc_user =&gt;&quot;root&quot;        jdbc_password =&gt;&quot;123456&quot;        # 定时查询        schedule =&gt;&quot;* * * * *&quot;        # 执行的sql语句，两种形式        #statement_filepath =&gt; &quot;/opt/test.sql&quot;        statement =&gt;&quot;SELECT * FROM tname&quot;    &#125;&#125;output &#123;    elasticsearch &#123;        # 转换ES索引        index =&gt;&quot;name_index&quot;        document_type =&gt;&quot;name_type&quot;        # 关联表中的id字段，对应索引id        document_id =&gt;&quot;%&#123;id&#125;&quot;        template_overwrite =&gt; true        hosts =&gt;[&quot;127.0.0.1:9200&quot;]    &#125;&#125;</code></pre><blockquote><p>选择filepath形式执行sql语句的话需要额外创建一个sql文件，在里面编写sql语句，这里省略。</p></blockquote><p>返回到logstash-6.1.1目录，然后执行：</p><pre><code>bin/logstash -f config/jdbc.conf</code></pre><p>等待一会，会看到终端输出了刚才写的sql语句，因为开启了schedule，根据以上配置大概30s就会执行一次sql查询，增量更新到ES的索引。需要注意的是，对于更新操作，目前插件都不能实现。</p><p>浏览器访问 http://服务器ip:9200/name_index/name_type/_search ，即可看到同步的数据。</p><p>最后将进程挂载后台让它一直做定时查询即可，方法参考上一篇文章。</p><h3 id="4-操作数据"><a href="#4-操作数据" class="headerlink" title="4. 操作数据"></a>4. 操作数据</h3><p>参考官方视图工具 <a href="https://www.elastic.co/cn/downloads/kibana">kibana</a> 选择对应版本，下载到本地，解压，进入<code>config/kibana.yml</code> 修改 <code>elasticsearch.url</code>为你服务器的ES地址，运行 <code>bin/kibana</code> 浏览器访问 <a href="http://localhost:5601/">http://localhost:5601</a> ，即可在本地连接线上ES服务器，比较常用的功能例如 <a href="https://www.elastic.co/guide/en/kibana/current/console-kibana.html">Dev Tools</a>。</p><blockquote><p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/index.html">Elasticsearch: 权威指南</a></p></blockquote><h3 id="5-多个数据表查询"><a href="#5-多个数据表查询" class="headerlink" title="5. 多个数据表查询"></a>5. 多个数据表查询</h3><pre><code>input &#123;        jdbc &#123;            jdbc_driver_library =&gt;&quot;/opt/mysql-connector-java-6.0.6.jar&quot;            jdbc_driver_class =&gt;&quot;com.mysql.jdbc.Driver&quot;            jdbc_connection_string =&gt;&quot;jdbc::3306/?characterEncoding=UTF-8&amp;useSSL=false&quot;            jdbc_user =&gt;&quot;&quot;            jdbc_password =&gt;&quot;&quot;            schedule =&gt;&quot;* * * * *&quot;            statement_filepath =&gt; &quot;/opt/order_goods.sql&quot;            #statement =&gt;&quot;SELECT * FROM tname&quot;                    type =&gt; &quot;jdbc_order_goods&quot;        &#125;            jdbc &#123;            jdbc_driver_library =&gt;&quot;/opt/mysql-connector-java-6.0.6.jar&quot;            jdbc_driver_class =&gt;&quot;com.mysql.jdbc.Driver&quot;            jdbc_connection_string =&gt;&quot;jdbc::3306/?characterEncoding=UTF-8&amp;useSSL=false&quot;            jdbc_user =&gt;&quot;&quot;            jdbc_password =&gt;&quot;&quot;            schedule =&gt;&quot;* * * * *&quot;            statement_filepath =&gt; &quot;/opt/user.sql&quot;                    type =&gt; &quot;jdbc_user&quot;        &#125;    &#125;output &#123;        if[type] == &quot;jdbc_order_goods&quot;&#123;        elasticsearch &#123;            hosts =&gt;[&quot;127.0.0.1:9200&quot;]                    index =&gt;&quot;order_goods_index&quot;            document_type =&gt;&quot;order_goods_type&quot;            document_id =&gt;&quot;%&#123;id&#125;&quot;        &#125;    &#125;    if[type] == &quot;jdbc_user&quot;&#123;        elasticsearch &#123;            hosts =&gt;[&quot;127.0.0.1:9200&quot;]            index =&gt; &quot;user_index&quot;            document_type =&gt; &quot;user_type&quot;            document_id =&gt; &quot;%&#123;id&#125;&quot;        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式搜索引擎ElasticSearch安装小记</title>
      <link href="/2018/01/16/old/%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8EElasticSearch%E5%85%A5%E9%97%A8%E5%B0%8F%E8%AE%B0/"/>
      <url>/2018/01/16/old/%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8EElasticSearch%E5%85%A5%E9%97%A8%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>ElasticSearch（下面简称ES）是一个开源的、基于Apache Lucene的、分布式的实时分析搜索引擎。其设计理念就是可以从不用的数据源获取数据，进行实时的检索和分析。</p></blockquote><p>利用ES可以减少数据库压力和数据复杂度，不用在原表大量添加索引，且可以使用廉价机器平行扩展性能，具有轻量高效的特点。</p><a id="more"></a><h3 id="0-Java安装及环境变量配置"><a href="#0-Java安装及环境变量配置" class="headerlink" title="0. Java安装及环境变量配置"></a>0. Java安装及环境变量配置</h3><blockquote><p>ElasticSearch基于Lucene封装了一套REST API，Lucene是Java开源库，所以需要在服务器(或本地)配置好Java环境，所需版本是jdk1.8以上。</p></blockquote><pre><code>java -version echo $JAVA_HOME</code></pre><h3 id="1-下载安装Elasticsearch"><a href="#1-下载安装Elasticsearch" class="headerlink" title="1. 下载安装Elasticsearch"></a>1. 下载安装Elasticsearch</h3><p>官方下载地址及安装方法：<a href="https://www.elastic.co/cn/downloads/elasticsearch">Download  Elasticsearch</a></p><p>以6.1.1版本为例：</p><pre><code>$ wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.1.1.zip$ unzip elasticsearch-6.1.1.zip$ cd elasticsearch-6.1.1/ $ ./bin/elasticsearch</code></pre><p>至此一个单节点集群就可以跑起来了，浏览器访问 <a href="http://localhost:9200/">http://localhost:9200</a> 即可</p><h3 id="2-Linux下的服务器配置"><a href="#2-Linux下的服务器配置" class="headerlink" title="2. Linux下的服务器配置"></a>2. Linux下的服务器配置</h3><p>首先进入Elasticsearch的目录，修改<code>config/elasticsearch.yml</code>，找到<code>network.host</code>一行，将其改为：</p><pre><code>network.host: 0.0.0.0</code></pre><p>注意去掉前面的#号注释，分号后的空格不能省略。<br>设成0.0.0.0让任何人都可以访问。具体可根据需要设置相应IP。</p><blockquote><p>正常在本地直接运行启动能跑起来，但服务器上到 <code>$ bin/elasticsearch</code>这一步就会报错了:</p></blockquote><pre><code>org.elasticsearch.bootstrap.StartupException: java.lang.RuntimeException: can not run elasticsearch as root</code></pre><blockquote><p>这是因为elastic限制了root账户直接启动，需要创建一个账户来启动：</p></blockquote><p>0 . 创建一个用户组</p><pre><code>groupadd elastic</code></pre><p>1 . 添加用户</p><pre><code>useradd 你的用户名 -g elastic -p 密码</code></pre><p>我第一次创建完后登录不上账号，可能是密码太过于简单，此时可以重新使用root账号登录，执行修改密码：</p><pre><code>passwd 用户名</code></pre><p>2 . 若此时登录该账号执行启动会提示“权限不足”，所以需要在root权限下，赋给文件夹执行权限</p><pre><code>chown -R 用户名 /opt/elasticsearch-6.1.1 (这里换成你Elasticsearch的目录)</code></pre><p>配置好了权限，再次运行下，可能又会报一个<code>bootstrap checks failed</code>的错误，不同的机器可能提示的错误不一样，好像是内存空间一类的配置问题，没有达到其要求的最低值，主要修改以下两个地方，root用户，执行：</p><pre><code>vi /etc/security/limits.conf </code></pre><p>添加以下内容：</p><pre><code>* soft nofile 65536* hard nofile 131072* soft nproc 2048* hard nproc 4096</code></pre><p>接着执行：</p><pre><code>vi /etc/sysctl.conf </code></pre><p>添加以下内容：</p><pre><code>vm.max_map_count=655360</code></pre><p>然后执行：</p><pre><code>sysctl -p</code></pre><blockquote><p>参考文章：<br><a href="http://www.cnblogs.com/sloveling/p/elasticsearch.html">http://www.cnblogs.com/sloveling/p/elasticsearch.html</a></p></blockquote><p>此时使用刚才创建的用户，进入elasticsearch目录执行<code>bin/elasticsearch</code>启动，启动成功，并且可以在外网访问，但是终端一关闭就不能访问了，配置在服务器上我们希望即使关闭终端也不销毁进程，这就需要让其挂在后台运行，在目录下执行：</p><pre><code>nohup bin/elasticsearch &amp;</code></pre><p>成功后提示 <code>$ nohup: 忽略输入并把输出追加到&quot;nohup.out&quot;</code></p><p>此时控制台不会输出运行情况了，<code>ctrl + c</code>退出来，执行：<code>jobs -l</code> 可查看当前挂在后台的进程：</p><pre><code>[1]+ 28290 运行中               nohup ./bin/elasticsearch &amp;</code></pre><p>如上<code>28290</code>即为该进程标识，结束进程可以执行</p><pre><code>kill -9 28290</code></pre><p>关闭终端，ES依然可以访问，但是重新ssh连接服务器后发现 <code>jobs -l</code> 无法查看到进程了，此时可执行：</p><pre><code>ps -u 用户名</code></pre><p>查看进程，看到一条正在运行的Java进程，如需结束进程依然可以使用上面的方法。</p>]]></content>
      
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git实用操作整理记录</title>
      <link href="/2017/12/28/old/git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%95%B4%E7%90%86/"/>
      <url>/2017/12/28/old/git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>记录某些可能不常用会忘记但实用的操作</p><a id="more"></a><h6 id="0-为当前版本打上-tag"><a href="#0-为当前版本打上-tag" class="headerlink" title="0. 为当前版本打上 tag"></a>0. 为当前版本打上 tag</h6><pre><code>git tag -a v1.0 -m &#39;version 1.0 code&#39;</code></pre><h6 id="1-查看所有-tag"><a href="#1-查看所有-tag" class="headerlink" title="1. 查看所有 tag"></a>1. 查看所有 tag</h6><pre><code>git tag</code></pre><h6 id="2-推送到远程仓库"><a href="#2-推送到远程仓库" class="headerlink" title="2. 推送到远程仓库"></a>2. 推送到远程仓库</h6><pre><code>git push origin --tags</code></pre><h6 id="2-1-重新修改-commit-备注"><a href="#2-1-重新修改-commit-备注" class="headerlink" title="2.1 重新修改 commit 备注"></a>2.1 重新修改 commit 备注</h6><pre><code>git commit --amend -m &quot;新的提交信息&quot;</code></pre><h6 id="3-删除远程分支和-tag"><a href="#3-删除远程分支和-tag" class="headerlink" title="3. 删除远程分支和 tag"></a>3. 删除远程分支和 tag</h6><blockquote><p>在 Git v1.7.0 之后，可以使用这种语法删除远程分支：</p></blockquote><pre><code>git push origin --delete &lt;branchName&gt;</code></pre><blockquote><p>删除 tag 这么用：</p></blockquote><pre><code>git push origin --delete tag &lt;tagname&gt;</code></pre><blockquote><p>否则，可以使用这种语法，推送一个空分支到远程分支，其实就相当于删除远程分支：</p></blockquote><pre><code>git push origin :&lt;branchName&gt;</code></pre><blockquote><p>推送一个空 tag 到远程 tag：</p></blockquote><pre><code>git tag -d &lt;tagname&gt;git push origin :refs/tags/&lt;tagname&gt;</code></pre><h6 id="4-少人协作时的骚操作，具体看怎么利用"><a href="#4-少人协作时的骚操作，具体看怎么利用" class="headerlink" title="4. 少人协作时的骚操作，具体看怎么利用"></a>4. 少人协作时的骚操作，具体看怎么利用</h6><p>假设你有 3 个 commit 如下：</p><pre><code>commit 3commit 2commit 1</code></pre><p>其中最后一次提交 commit 3 是错误的，那么可以执行：</p><pre><code>git reset --hard HEAD~1</code></pre><p>你会发现，<code>HEAD is now at commit 2</code>，然后再使用</p><pre><code>git push --force</code></pre><p>将本次变更强行推送至服务器。这样在服务器上的最后一次错误提交也彻底消失了。</p><p>值得注意的是，这类操作比较比较危险，例如：在你的 commit 3 之后别人又提交了新的 commit 4，那在你强制推送之后，那位仁兄的 commit 4 也跟着一起消失了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 备忘记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue相关笔记及思考</title>
      <link href="/2017/12/25/old/vue%E7%AC%94%E8%AE%B0/"/>
      <url>/2017/12/25/old/vue%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>记录vue2.0开发过程中个人认为需要注意的东西。</p><a id="more"></a><ul><li><p>事件：v-on:click/mouseover <code>推荐写法： @click=&quot;&quot;</code></p></li><li><p>属性：v-bind:src=”” <code>推荐写法： :src=&quot;&quot;</code></p></li><li><p><code>&lt;img src=&quot;&#123;&#123;url&#125;&#125;&quot; alt=&quot;&quot;&gt;</code>    效果能出来，但是会报一个404错误</p></li><li><p><code>&lt;img v-bind:src=&quot;url&quot; alt=&quot;&quot;&gt;</code>    效果可以出来，不会发404错误</p></li><li><p>补充中…</p></li></ul><blockquote><p>随手解决了但原理还未完全搞懂的奇怪问题：</p></blockquote><ul><li>如此绑定图片不使用require会报404：<br><code>:src=&quot;userInfo.avater||require(&#39;../../assets/images/default-avater.png&#39;)&quot; </code></li></ul><h5 id="vue响应式原理"><a href="#vue响应式原理" class="headerlink" title="vue响应式原理"></a>vue响应式原理</h5><p>是基于es5的<code>Object.defineProperty</code>实现的</p><h3 id="关于模板"><a href="#关于模板" class="headerlink" title="关于模板:"></a>关于模板:</h3><pre><code>&#123; &#123; msg &#125; &#125;        数据更新模板变化&#123; &#123; *msg &#125; &#125;       数据只绑定一次&#123; &#123; &#123; msg &#125; &#125; &#125;    HTML转义输出</code></pre><h3 id="vue生命周期"><a href="#vue生命周期" class="headerlink" title="vue生命周期:"></a>vue生命周期:</h3><pre><code>beforeCreate     组件实例刚刚被创建,属性都没有created          实例已经创建完成，属性已经绑定beforeMount      模板编译之前mounted          模板编译之后（vue1.x是ready）beforeUpdate     组件更新之前updated          组件更新完毕beforeDestroy    组件销毁前destroyed        组件销毁后</code></pre><blockquote><p>created 后组件创建完毕，可以操作data数据，ajax请求可在此进行<br><br>mounted 通常加上nextTick使用<br><br>activated 配合keep-alive使用</p></blockquote><h3 id="计算属性的使用"><a href="#计算属性的使用" class="headerlink" title="计算属性的使用:"></a>计算属性的使用:</h3><pre><code>computed:&#123;    a:function() &#123;     //默认调用get        return 值    &#125;,    b() &#123;        return ..    &#125;&#125;</code></pre><h3 id="关于循环："><a href="#关于循环：" class="headerlink" title="关于循环："></a>关于循环：</h3><pre><code>v-for=&quot;value in data&quot;</code></pre><p>现在这么写开发环境会提示错误，需要绑定key值；<br>因为vue实现了一套虚拟DOM来使操作数据可以重新渲染页面，<br>而key的作用主要是为了高效的更新虚拟DOM。<br>需要注意的是key值最好为唯一的标识符，不要以index作为key。</p><pre><code>v-for=&quot;(item, index) in data&quot; :key=&quot;item.id&quot;</code></pre><h3 id="过渡-动画"><a href="#过渡-动画" class="headerlink" title="过渡(动画)"></a>过渡(动画)</h3><p>本质 css3: transtion ,animation</p><pre><code>&lt;transition name=&quot;fade&quot;&gt;    运动东西(元素，属性、路由....)&lt;/transition&gt;class定义:.fade-enter&#123;&#125;    //初始状态.fade-enter-active&#123;&#125;  //变化成什么样  -&gt;  当元素出来(显示).fade-leave&#123;&#125;.fade-leave-active&#123;&#125; //变成成什么样   -&gt; 当元素离开(消失)</code></pre><h3 id="关于通信"><a href="#关于通信" class="headerlink" title="关于通信"></a>关于通信</h3><p>为什么使用vuex (状态管理器)：</p><p><strong>好处：</strong></p><ul><li>use Baidu or Google</li></ul><p><strong>缺点：</strong></p><ul><li>引入了新的概念和层次</li><li>频繁使用会增加代码耦合</li></ul><p><strong>解决了：</strong></p><ul><li>vue传参的方法对于多层嵌套的组件非常繁琐</li><li>vue对于父子组件是单向通信，对于兄弟组件间的状态传递无能为力</li><li>将多个组件调用的相同数据统一管理，方便以后代码维护。</li></ul><p><strong>不使用vuex如何通信：</strong><a href="https://cn.vuejs.org/v2/guide/components.html#%E9%9D%9E%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E7%9A%84%E9%80%9A%E4%BF%A1">eventbus</a></p><ul><li>vue1.x中使用dispatch broadcast类似广播事件的做法，在2.0中已经废弃，改用eventbus，使用上感觉差不多。</li></ul><p><strong>总结：</strong></p><p>父子组件单向数据传递使用prop，非父子组件通信使用eventBus，更复杂的多层嵌套的组件通信使用vuex。<br>使用vue要本着灵活高效为出发点。<br>为何vuex可以解决复杂的通信？因为它相当于将数据全局托管。</p><p><strong>补充：</strong></p><p>例如从A页面跳转到B页面，需要实现A页面点击立即先请求数据，请求完毕再跳转至B页面加载内容，这里使用eventbus做一个案例：</p><ul><li>A组件中跳转至B组件的点击事件进行ajax请求，请求完毕后做以下逻辑：</li></ul><pre><code>self.$router.push(&#123; name: &quot;user_address&quot; &#125;);setTimeout(() =&gt; &#123;    self.$bus.$emit(&#39;addressLoad&#39;,res.content);&#125;, 1);</code></pre><ul><li>B页面中的create中创建bus监听：</li></ul><pre><code>this.$bus.$on(&quot;addressLoad&quot;, function(data) &#123;  self.addressData = data;&#125;);</code></pre><p><code>self</code>指代ajax回调外面的this(vue实例)。<br><code>this.$bus</code>为挂载在全局的一个空vue实例</p><p>因为A组件直接触发事件的话B组件还未创建监听，所以这里使用setTimeout将A组件中的触发事件放在低优先级的队列中执行。</p><p>vue非常灵活，该案例可能有更好的方法实现。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac中截图快捷键及截图名称配置</title>
      <link href="/2017/12/11/old/Mac%E4%B8%AD%E6%88%AA%E5%9B%BE%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%8F%8A%E6%88%AA%E5%9B%BE%E5%90%8D%E7%A7%B0%E9%85%8D%E7%BD%AE/"/>
      <url>/2017/12/11/old/Mac%E4%B8%AD%E6%88%AA%E5%9B%BE%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%8F%8A%E6%88%AA%E5%9B%BE%E5%90%8D%E7%A7%B0%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>Command + Shift + 3 截取全屏</p><p>Command + Shift + 4 鼠标变成十字，点击选取屏幕区域截图</p><p>截图完成自动保存在桌面，文件名比较长，而且带有中文，此时可以自定义截图后保存的名称：</p><a id="more"></a><p>打开“终端”，粘贴以下文本并回车：</p><blockquote><p>defaults write com.apple.screencapture name “Snapshot”</p></blockquote><ul><li>这里的<code>Snapshot</code>就是代替“屏幕截图”几个字的文本，可以更改。</li></ul><p>同样的再执行以下文本以让配置生效：</p><blockquote><p>killall SystemUIServer</p></blockquote><p>打开“系统偏好设置”，选择“语言与地区”，点击窗口右下“高级..”，切换上面tab至“时间”，将“正午前”跟“正午后”的中文定义修改为“AM”、“PM”。</p><p>之后保存在桌面的屏幕截图名称就为全英文了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 备忘记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>突破百度网盘下载限速</title>
      <link href="/2017/12/05/old/%E7%AA%81%E7%A0%B4%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E4%B8%8B%E8%BD%BD%E9%99%90%E9%80%9F/"/>
      <url>/2017/12/05/old/%E7%AA%81%E7%A0%B4%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E4%B8%8B%E8%BD%BD%E9%99%90%E9%80%9F/</url>
      
        <content type="html"><![CDATA[<p>更新：网盘下载器<a href="http://pandownload.com/">链接</a></p><p>Windows下可以使用无限试用版百度网盘客户端来突破限速，网上搜一下就有，其原理是延长客户端会员试用计时，这样就相当于一直拥有会员下载加速了。</p><p>Mac端使用谷歌浏览器来突破限制，简单两步。</p><a id="more"></a><h3 id="1-下载解压安装-Aria2GUI-for-MAC-OS-X"><a href="#1-下载解压安装-Aria2GUI-for-MAC-OS-X" class="headerlink" title="1. 下载解压安装 Aria2GUI for MAC OS X "></a>1. 下载解压安装 <a href="https://github.com/yangshun1029/aria2gui/releases">Aria2GUI for MAC OS X </a></h3><p>以后每次下载网盘资源的时候需要先打开这个Aria2GUI客户端。</p><h3 id="2-下载谷歌浏览器网盘插件-BaiduExporter"><a href="#2-下载谷歌浏览器网盘插件-BaiduExporter" class="headerlink" title="2. 下载谷歌浏览器网盘插件 BaiduExporter"></a>2. 下载谷歌浏览器网盘插件 <a href="https://github.com/acgotaku/BaiduExporter">BaiduExporter</a></h3><p>将**<code>crx</code>**后缀的文件拖到谷歌扩展程序界面安装并启用。</p><ul><li><p>在网盘页面<code>导出下载</code>中会多出<code>ARIA2 RPC</code>的选项(可能需要重启浏览器)，选择要下载的文件点击该选项即可满速下载。<br><img src= "/img/loading__.gif" data-lazy-src="http://img.palxp.com/blog/image/Snapshot%202017-12-11%20PM3.25.36.png"></p></li><li><p>建议将分享资源先保存至自己的网盘再调用下载。</p></li><li><p>遇到谷歌扩展程序失效停用参考：</p></li></ul><blockquote><p><a href="http://xclient.info/a/1ddd2a3a-d34b-b568-c0d0-c31a95f0b309.html?_=776663b8113038b40b4ec2662bb75a16">将非官方扩展程序加入chrome的白名单</a></p><p><a href="http://xclient.info/a/6b6c46df-3e4f-1b17-ae30-0c8b49df92cc.html?_=776663b8113038b40b4ec2662bb75a16">参考资料</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 备忘记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github pages + hexo 优雅地打造免费个人静态网页博客</title>
      <link href="/2017/12/04/old/Github-pages-hexo-%E6%89%93%E9%80%A0%E5%85%8D%E8%B4%B9%E4%BC%98%E9%9B%85%E7%9A%84%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E5%8D%9A%E5%AE%A2/"/>
      <url>/2017/12/04/old/Github-pages-hexo-%E6%89%93%E9%80%A0%E5%85%8D%E8%B4%B9%E4%BC%98%E9%9B%85%E7%9A%84%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>前言</strong>：近期觉得写博客这件事必须提到日程了，一方面养成做笔记做总结的习惯，同时也能做些生活记录，提高写作能力，其实有很多不错的博客平台都可以用，自然曝光率可能也比较高，但是咱好歹也是程序员，博客网站不自己搭建一个感觉就有点没逼格，但这样至少需要域名空间和博客程序，对于写博客这个出发点似乎成本有点高。</p></blockquote><p>后来发现很多大牛的个人博客都在用hexo，折腾了一下觉得简单又实用，markdown编写git发布，静态网页速度快，稳定性高，还利于搜索引擎收录，对于博客程序来说这一切足够了。听说还可以集成vue、angular等。</p><a id="more"></a><h3 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h3><ul><li>必要环境及工具的下载：</li></ul><ol><li><a href="https://nodejs.org/zh-cn/">Node.js</a> 安装后也会安装好<a href="https://www.npmjs.com/"> npm </a>包管理工具。</li><li><a href="https://git-scm.com/downloads">Git</a> 用于提交代码的工具，mac下安装了xcode则忽略这步。</li><li>需要一个Github账号，使用它提供的<a href="https://pages.github.com/"> Pages </a>功能就可以拥有一个静态网站空间，而且是免费的。国内的<a href="https://coding.net/"> Coding </a>也能做到同样的事，这里我还是选择github作为例子，原理都一样按需选择。</li></ol><ul><li>申请个自己的域名(非必须)</li></ul><h3 id="2-安装HEXO博客程序"><a href="#2-安装HEXO博客程序" class="headerlink" title="2. 安装HEXO博客程序"></a>2. 安装HEXO博客程序</h3><ul><li><p>mac下打开<code>终端</code>，如果嫌cd命令找目录麻烦，可以打开finder，点击左上角苹果图标旁边的<code>Finder</code>-&gt;<code>服务</code>-&gt;<code>服务偏好设置</code>-&gt;勾选<code>新建位于文件夹位置的终端窗口</code>，以后便可以在目录文件夹右键选择<code>服务</code>-&gt;<code>...位置的终端窗口</code>。</p></li><li><p>windows在磁盘随便一个目录空白处右键选择<code>在此处打开GitBash</code> (使用cmd也可以，不推荐)</p></li><li><p>在终端执行以下命令安装hexo (以下所有命令在windows下都不需要加sudo)</p></li></ul><p><code>sudo npm install -g hexo</code></p><h3 id="3-初始化博客"><a href="#3-初始化博客" class="headerlink" title="3. 初始化博客"></a>3. 初始化博客</h3><ul><li><p>创建一个文件夹用于存放博客资源目录，在该目录下打开终端执行：<code>hexo init</code></p></li><li><p>第一次初始化需要稍作等待，完成后再执行：<code>hexo g</code></p></li><li><p>该命令作用是构建文章页面，就是生成静态网页，最后执行：<code>hexo s</code></p></li></ul><p>此时自动启动本地测试服务器，浏览器访问 <a href="http://localhost:4000/">http://localhost:4000</a> 即可查看初始化好的博客。</p><blockquote><p>初始化博客可能报错：ERROR Plugin load failed: hexo-server<br>解决方法：执行 <code>sudo npm install hexo-server</code> </p></blockquote><h3 id="4-部署博客"><a href="#4-部署博客" class="headerlink" title="4. 部署博客"></a>4. 部署博客</h3><p>经过以上步骤，我们已经可以将博客程序跑起来了，非常简单。接下来就要将它与Pages关联。</p><p>登录github并创建一个repository，点击“New repository”创建存放博客的仓库，注意仓库名必须为xxx(自定义前缀).github.io，这个也是你博客默认的访问地址。</p><p>进入博客资源目录(即刚刚初始化的目录)，打开根目录的_config.yml文件，在末尾添加：</p><pre><code>deploy:  type: git  repository: https://github.com/xxx/xxx.github.io.git  branch: master</code></pre><p>仓库地址为前面创建的github仓库地址</p><ul><li><p>接着在终端执行以下命令：<code>npm install hexo-deployer-git --save</code></p></li><li><p>cd到博客目录执行：<code>hexo d</code></p></li></ul><p>你会发现博客已经部署到giuhub仓库中，可以通过外网访问了。</p><h3 id="5-开始写博客"><a href="#5-开始写博客" class="headerlink" title="5. 开始写博客"></a>5. 开始写博客</h3><ol><li>安装一个编写md文件的工具，例如我使用的是<a href="http://macdown.uranusjr.com/">MacDown</a>。</li><li>cd到博客目录执行<code>hexo new &quot;postName&quot;</code> 创建文章。</li><li>博客目录下的<code>source</code>/<code>_posts</code>找到你创建的文章，打开直接编写即可。 </li><li><a href="https://hexo.io/zh-cn/docs/writing.html">hexo中文文档</a></li></ol><h3 id="6-发布你的博客"><a href="#6-发布你的博客" class="headerlink" title="6. 发布你的博客"></a>6. 发布你的博客</h3><p>每次编写博客的步骤：</p><ol><li>本地写好博客</li><li>打开终端，cd到博客目录，执行 <code>hexo clean</code> 清空缓存</li><li>执行 <code>hexo g</code> 构建文章页面</li><li>执行 <code>hexo s</code> 本地预览整个站点</li><li>执行 <code>hexo d</code> 发布到Pages更新线上博客</li></ol><h3 id="7-博客绑定自己的域名"><a href="#7-博客绑定自己的域名" class="headerlink" title="7. 博客绑定自己的域名"></a>7. 博客绑定自己的域名</h3><p>域名解析CNAME记录到你仓库的默认域名，创建一个文本，写上你解析的域名，放在仓库根目录即可。</p><ul><li>重新生成网页文件会把 CNAME 文件覆盖掉，需要直接把 CNAME 文件添加到 source 文件夹里，这样每次推的时候就不用担心仓库里的 CNAME 文件被覆盖掉了。</li><li>仓库设置中出现Domain’s DNS record could not be retrieved.提示说明CNAME文件出错，检查该文件域名是否拼写错误，注意不要加http前缀。</li></ul><h3 id="8-博客美化"><a href="#8-博客美化" class="headerlink" title="8. 博客美化"></a>8. 博客美化</h3><p>hexo拥有大量优秀主题，本站使用 <a href="https://github.com/litten/hexo-theme-yilia">yilia</a> 主题。</p><p>yilia主题支持配置多种评论系统，本站使用畅言。</p><p>….</p>]]></content>
      
      
      
        <tags>
            
            <tag> 个人博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
